

---
title: "spatial_prioritization_pipeline"
output: html_document
---

```{r eval=FALSE, include=FALSE}
library(data.table)
library(terra)
library(sf)

# ------------------------------------------------------------
# 1. Target species lists
# ------------------------------------------------------------
target_mammal_species <- c(
  "gymnuromys roberti", "nesomys rufus", "eliurus minor",
  "eliurus majori", "eliurus myoxinus", "eliurus tanala",
  "eliurus webbi", "cryptoprocta ferox", "fossa fossana",
  "galidia elegans", "echinops telfairi", "hemicentetes semispinosus",
  "microgale brevicaudata", "microgale cowani", "nesogale dobsoni",
  "microgale gymnorhyncha", "microgale longicaudata", "microgale parvula",
  "microgale principula", "microgale soricoides", "microgale taiva",
  "nesogale talazaci", "oryzorictes hova", "setifer setosus",
  "tenrec ecaudatus", "eulemur fulvus", "eulemur rufus",
  "hapalemur griseus", "indri indri", "lepilemur edwardsi",
  "lepilemur leucopus", "lepilemur ruficaudatus", "varecia variegata",
  "cheirogaleus medius", "cheirogaleus major", "microcebus rufus",
  "eulemur albifrons", "eulemur coronatus", "microcebus murinus",
  "eulemur rubriventer", "lepilemur mustelinus"
)

target_bird_species <- c(
  "accipiter madagascariensis", "coua coquereli", "coua serriana",
  "coua cursor", "apus balstoni", "asio madagascariensis",
  "philepitta castanea", "neodrepanis coruscans", "foudia madagascariensis",
  "hartlaubius auratus", "foudia omissa", "ploceus nelicourvi",
  "accipiter henstii", "newtonia amphichroa", "mentocrex kioloides",
  "calicalicus madagascariensis", "coua cristata", "brachypteracias leptosomus",
  "lophotibis cristata", "atelornis crossleyi", "turnix nigricollis",
  "buteo brachypterus", "pterocles personatus", "corythornis madagascariensis",
  "lepidopygia nana", "eremopterix hova", "acrocephalus newtoni",
  "motacilla flaviventris", "monticola sharpei", "xanthomixis cinereiceps",
  "oxylabes madagascariensis", "neomixis viridis", "hypositta corallirostris",
  "newtonia brunneicauda", "mystacornis crossleyi", "cyanolanius madagascarinus",
  "xanthomixis zosterops", "bernieria madagascariensis", "coua gigas",
  "pseudobias wardi", "neomixis striatigula", "gactornis enarratus",
  "coracopsis nigra", "athene superciliaris", "alectroenas madagascariensis",
  "polyboroides radiatus", "tylas eduardi", "aviceda madagascariensis",
  "vanga curvirostris", "leptopterus chabert", "artamella viridis",
  "sarothrura insularis", "otus rutilus", "cinnyris notatus",
  "treron australis"
)

# ------------------------------------------------------------
# 2. Load and prepare parameter table
# ------------------------------------------------------------
params_mammal_raw <- fread("Data/Clean/mammal_data.csv")
params_bird_raw   <- fread("Data/Clean/bird_data.csv")

# 1. Filter raw tables to target species (keep ALL columns)
params_mammal_spatial <- params_mammal_raw[
  scientificName %in% target_mammal_species
]

params_bird_spatial <- params_bird_raw[
  scientificName %in% target_bird_species
]

# 2. Write to CSV in the Spatial folder
data.table::fwrite(
  params_mammal_spatial,
  file = file.path("Spatial", "params_mammal_target_species.csv")
)

data.table::fwrite(
  params_bird_spatial,
  file = file.path("Spatial", "params_bird_target_species.csv")
)

param_cols <- c(
  "min_patch_size",
  "min_patch_size500",
  "a_pred",
  "b_pred",
  "density",
  "dispersal_dist"
)

params_mammal <- params_mammal_raw[
  scientificName %in% target_mammal_species,
  c(list(species = gsub(" ", "_", scientificName)), .SD),
  .SDcols = param_cols
]

params_bird <- params_bird_raw[
  scientificName %in% target_bird_species,
  c(list(species = gsub(" ", "_", scientificName)), .SD),
  .SDcols = param_cols
]

params <- rbindlist(list(params_mammal, params_bird), use.names = TRUE)
setkey(params, species)

# ------------------------------------------------------------
# 3. Patch raster stack + cell areas + rook adjacency
# ------------------------------------------------------------
patch_files <- file.path("Spatial", "Patches", paste0(params$species, ".tif"))
patch_stack <- rast(patch_files)
names(patch_stack) <- params$species

template_rast <- patch_stack[[1]]

cs_vals <- as.numeric(
  values(cellSize(template_rast, unit = "km"), mat = TRUE)[, 1]
)

rook_pairs_all <- adjacent(
  template_rast,
  cells      = seq_len(ncell(template_rast)),
  directions = 4,
  pairs      = TRUE
)

# ------------------------------------------------------------
# 4. Patch lookup table (patch_dt)
# ------------------------------------------------------------
patch_dt_mammal <- as.data.table(readRDS("Spatial/all_mammal_patch_lookup.rds"))
patch_dt_bird   <- as.data.table(readRDS("Spatial/all_bird_patch_lookup.rds"))

patch_dt <- rbindlist(list(patch_dt_mammal, patch_dt_bird), use.names = TRUE)[
  species %in% params$species
]

patch_dt[, species  := as.character(species)]
patch_dt[, patch_id := as.integer(patch_id)]
patch_dt[, pu_id    := as.integer(pu_id)]

# Key for fast joins in downstream stages
setkey(patch_dt, species, patch_id)

# ------------------------------------------------------------
# 5. Connectivity graphs (state_env)
# ------------------------------------------------------------
filter_state_by_species <- function(state_env_all, keep_species) {
  if (!length(state_env_all)) return(state_env_all)
  sp_in_names <- vapply(
    strsplit(names(state_env_all), "\\|"),
    `[`,
    character(1L),
    1
  )
  state_env_all[sp_in_names %in% keep_species]
}

state_env_mammal_all <- readRDS("Spatial/all_mammal_connectivity.rds")
state_env_bird_all   <- readRDS("Spatial/all_bird_connectivity.rds")

state_env_mammal <- filter_state_by_species(state_env_mammal_all, params$species)
state_env_bird   <- filter_state_by_species(state_env_bird_all,   params$species)

state_env <- c(state_env_mammal, state_env_bird)

# ------------------------------------------------------------
# 6. Initial per-cell alive counts
# ------------------------------------------------------------
patch_vals_all <- terra::values(patch_stack, mat = TRUE)
count_alive    <- rowSums(!is.na(patch_vals_all))

rm(patch_vals_all)
gc(verbose = FALSE)

# ------------------------------------------------------------
# 7. Save inputs to disk
#    - SpatRaster saved separately via writeRaster()
#    - Other objects (plus the raster path) saved as RDS
# ------------------------------------------------------------
dir.create("Spatial", showWarnings = FALSE, recursive = TRUE)

patch_stack_file <- file.path("Spatial", "patch_stack.tif")

terra::writeRaster(
  patch_stack,
  filename  = patch_stack_file,
  overwrite = TRUE
)

orchestrator_init <- list(
  params          = params,
  patch_dt        = patch_dt,
  state_env       = state_env,
  cs_vals         = cs_vals,
  rook_pairs_all  = rook_pairs_all,
  count_alive     = count_alive,
  patch_stack_file = patch_stack_file
)

saveRDS(
  orchestrator_init,
  file = file.path("Spatial", "global_orchestrator_init.rds")
)

# ------------------------------------------------------------
# 8. Environment cleanup: keep only orchestrator inputs
# ------------------------------------------------------------
keep_objects <- c(
  "params",
  "patch_stack",
  "patch_dt",
  "state_env",
  "cs_vals",
  "rook_pairs_all",
  "count_alive",
  "patch_stack_file",
  ".log_console"
)

rm(list = setdiff(ls(envir = .GlobalEnv), keep_objects), envir = .GlobalEnv)
gc(verbose = FALSE)
```

# Shared static setup (used by both runs)

```{r}
library(fasterRaster)  
faster(grassDir = "C:/Program Files/GRASS GIS 8.4")
```

```{r}
library(data.table)
library(terra)
library(sf)

# Optional: logging helper
.log_console <- function(tag, fmt, ...) {
  ts  <- format(Sys.time(), "%Y-%m-%d %H:%M:%S")
  msg <- if (length(list(...))) sprintf(fmt, ...) else fmt
  cat(sprintf("[%s] [%s] %s\n", ts, tag, msg), sep = "")
}

# Use great-circle distances for sf::st_distance()
sf::sf_use_s2(TRUE)

# ------------------------------------------------------------
# Load shared, static parameters used by BOTH orchestrator runs
# ------------------------------------------------------------
orchestrator_init <- readRDS(
  file.path("Spatial", "global_orchestrator_init.rds")
)

# Only keep the static/shared bits here
params         <- orchestrator_init$params
cs_vals        <- orchestrator_init$cs_vals
rook_pairs_all <- orchestrator_init$rook_pairs_all

rm(orchestrator_init)
gc(verbose = FALSE)
```

# prune_step_minimal

```{r}
# ------------------------------------------------------------
# Connected components in a PU connectivity graph (CSR format)
# ------------------------------------------------------------
.compute_components <- function(row_ptr, col_idx, alive, patch_area) {
  # row_ptr, col_idx: CSR adjacency for one PU
  #   - nodes are patches
  #   - row_ptr[i]..row_ptr[i+1]-1 index into col_idx for neighbors of node i
  # alive: logical vector of length N indicating which nodes remain in the PU
  # patch_area: numeric vector of per-node areas (aligned with alive)

  N       <- length(alive)          # total number of nodes (patches) in this PU
  comp_id <- integer(N)             # component label for each node (0 = unlabeled)
  q       <- integer(N)             # preallocated BFS queue (max N entries)
  lab     <- 0L                     # current component label (we increment this)

  # We want to find connected components **only among alive nodes**.
  # This is needed so we can later:
  #   - compute each component's total area
  #   - decide which components survive the PU-area threshold.
  # We use a BFS over alive nodes for O(N + E) time, which is optimal for this graph task.

  # Iterate only over alive nodes; dead nodes are ignored entirely.
  for (u in which(alive)) {
    # If this node already has a component label, it was visited in a previous BFS.
    if (comp_id[u] != 0L) next

    # Start a new component: increment label and seed BFS at u.
    lab <- lab + 1L
    comp_id[u] <- lab

    # Initialize BFS queue with this node.
    qs <- 1L      # queue start index (head)
    qe <- 1L      # queue end index (tail)
    q[1L] <- u

    # Standard BFS: traverse along alive neighbors, labelling them with 'lab'.
    while (qs <= qe) {
      v <- q[qs]; qs <- qs + 1L

      # Neighbor slice for node v in CSR representation is:
      #   col_idx[row_ptr[v] + 1L .. row_ptr[v+1L]]
      s <- row_ptr[v] + 1L
      e <- row_ptr[v + 1L]

      # Only proceed if there is at least one neighbor.
      if (e >= s) {
        # Examine all neighbor indices for v
        for (idx in s:e) {
          w <- col_idx[idx]
          # Only traverse neighbors that are alive and not yet labeled:
          # this ensures we:
          #   - restrict components to alive nodes
          #   - avoid revisiting nodes, so BFS stays O(N + E).
          if (alive[w] && comp_id[w] == 0L) {
            comp_id[w] <- lab
            qe <- qe + 1L
            q[qe] <- w
          }
        }
      }
    }
  }

  # After BFS, comp_id[i] > 0 means node i is in some component.
  ok <- comp_id > 0L

  # We now need the **area per component**, because the PU update logic
  # uses component area to decide which components survive (>= thr) or are dropped.
  # rowsum() gives a fast vectorised group-sum over components.
  comp_area <- as.numeric(
    rowsum(patch_area[ok], comp_id[ok], reorder = FALSE)
  )

  # comp_id: component label per node
  # comp_area: total area per component label (index by component ID, 1..max label)
  list(comp_id = comp_id, comp_area = comp_area)
}

# ------------------------------------------------------------
# Rebuild a CSR graph restricted to a subset of nodes
# ------------------------------------------------------------
.rebuild_csr <- function(row_ptr, col_idx, keep_idx) {
  # We want the **induced subgraph** on the node subset keep_idx.
  # This is needed after dropping patches / components so that the
  # connectivity structure of each surviving component is still valid.
  #
  # This function:
  #   - remaps the original node indices to new compact indices 1..K
  #   - rebuilds CSR arrays (row_ptr, col_idx) for just those K nodes.

  N <- length(row_ptr) - 1L         # original number of nodes
  K <- length(keep_idx)             # number of nodes we keep in the subgraph

  # 'map' converts old node index -> new node index (0 = dropped)
  map           <- integer(N)
  map[keep_idx] <- seq_len(K)

  # New row_ptr will have K+1 entries (standard CSR convention).
  row_new <- integer(K + 1L)

  # ------------------------
  # First pass: count edges
  # ------------------------
  # We compute how many edges each kept node will have in the new graph.
  # This lets us compute row_new (cumulative counts), and then size col_new exactly.

  for (ii in seq_len(K)) {
    i <- keep_idx[ii]              # original node index
    s <- row_ptr[i] + 1L
    e <- row_ptr[i + 1L]

    if (e >= s) {
      neigh <- col_idx[s:e]        # neighbors in old indexing
      nn    <- map[neigh]          # map neighbors to new indexing
      nn    <- nn[nn > 0L]         # drop neighbors that were not kept
      # row_new[ii+1] = row_new[ii] + number of kept neighbors
      row_new[ii + 1L] <- row_new[ii] + length(nn)
    } else {
      # No neighbors for this node: just propagate the cumulative count.
      row_new[ii + 1L] <- row_new[ii]
    }
  }

  # Total number of edges in the new graph is row_new[K+1].
  col_new <- integer(row_new[K + 1L])

  # Write pointer into col_new
  wp      <- 1L

  # -------------------------
  # Second pass: fill edges
  # -------------------------
  # Now that we know the edge counts and row_new offsets, we can fill col_new.

  for (ii in seq_len(K)) {
    i <- keep_idx[ii]
    s <- row_ptr[i] + 1L
    e <- row_ptr[i + 1L]

    if (e >= s) {
      neigh <- col_idx[s:e]
      nn    <- map[neigh]
      nn    <- nn[nn > 0L]
      len   <- length(nn)
      if (len > 0L) {
        # Fill contiguous slice of col_new for node ii
        col_new[wp:(wp + len - 1L)] <- nn
        wp <- wp + len
      }
    }
  }

  # Return CSR arrays for the restricted graph
  list(row_ptr = row_new, col_idx = col_new)
}

# ------------------------------------------------------------
# Update components of a PU after some patches die
# ------------------------------------------------------------
.update_pu_components <- function(conn, alive_nodes, patch_area, thr, next_pu_id) {
  # conn: a CSR PU connectivity object:
  #   - conn$pu_id    : current PU ID
  #   - conn$id2patch : vector mapping node index -> patch_id
  #   - conn$row_ptr, conn$col_idx: CSR adjacency
  # alive_nodes: logical vector indicating which nodes (patches) survived in this PU
  # patch_area: numeric vector of per-node areas (aligned with alive_nodes)
  # thr: PU-level area threshold (min_patch_size500)
  # next_pu_id: next available PU ID for splitting components into new PUs
  #
  # Goal:
  #   - Split the PU into connected components of surviving patches
  #   - Drop any component whose total area < thr
  #   - Assign PU IDs to surviving components and rebuild their CSR graphs
  #   - Return:
  #       csr_list     : list of component CSR objects that survive
  #       drop_patches : patch_ids to be removed because they belong to
  #                      sub-threshold components
  #       next_pu_id   : updated next-pu counter for downstream calls

  n_alive <- sum(alive_nodes)

  # Case 1: no surviving patches → the PU disappears completely.
  # We don't drop any additional patches here (they are already "dead" by alive_nodes).
  if (n_alive == 0L) {
    return(list(
      csr_list     = list(),        # no surviving components
      drop_patches = integer(0L),   # nothing new to drop; all dead already
      next_pu_id   = next_pu_id
    ))
  }

  # Case 2: exactly one surviving patch
  # This is a special, very cheap case:
  #   - no connectivity edges are needed (1-node graph)
  #   - we just check the PU-threshold on that patch's area.
  if (n_alive == 1L) {
    idx_alive  <- which(alive_nodes)[1L]   # index of surviving node
    area_alive <- patch_area[idx_alive]

    # If the area of that single patch is below the PU threshold,
    # the whole component (i.e., this last patch) should be dropped.
    if (area_alive < thr) {
      return(list(
        csr_list     = list(),                  # PU disappears
        drop_patches = conn$id2patch[idx_alive],# drop that patch at PU level
        next_pu_id   = next_pu_id
      ))
    }

    # Otherwise, keep it as a 1-node PU with no edges (row_ptr = c(0, 0)).
    csr_obj <- list(
      pu_id    = conn$pu_id,
      id2patch = conn$id2patch[idx_alive],
      row_ptr  = c(0L, 0L),
      col_idx  = integer(0L)
    )

    return(list(
      csr_list     = list(csr_obj),  # one surviving component
      drop_patches = integer(0L),    # nothing further to drop
      next_pu_id   = next_pu_id
    ))
  }

  # Case 3: general multi-node case
  # We have multiple surviving patches; they may form one or more
  # connected components. Some components may be sub-threshold in area.

  # Compute per-node component labels and per-component areas.
  comps     <- .compute_components(conn$row_ptr, conn$col_idx, alive_nodes, patch_area)
  comp_id   <- comps$comp_id   # component label for each node (0 if dead)
  comp_area <- comps$comp_area # area per component label (1..max label)

  # Identify labels of components that survive (<-> keep) and those that drop.
  keep_labels <- which(comp_area >= thr)
  drop_labels <- which(comp_area <  thr)

  k_keep   <- length(keep_labels)
  csr_list <- vector("list", k_keep)  # will store CSR objects for surviving components

  if (k_keep > 0L) {
    base_pu_id <- conn$pu_id

    # If there is more than one surviving component, we need to assign new PU IDs.
    # Convention: first component keeps the original pu_id, additional components
    # get new ones from next_pu_id, next_pu_id+1, ...
    if (k_keep > 1L) {
      pu_ids     <- c(base_pu_id, next_pu_id + seq_len(k_keep - 1L))
      next_pu_id <- pu_ids[k_keep]      # advance counter
    } else {
      pu_ids <- base_pu_id              # only one component, keep pu_id
    }

    # For each surviving component, rebuild a CSR graph restricted to its nodes.
    for (j in seq_along(keep_labels)) {
      lab       <- keep_labels[j]
      nodes_lab <- which(comp_id == lab)             # original node indices for this component

      newg <- .rebuild_csr(conn$row_ptr, conn$col_idx, nodes_lab)

      csr_list[[j]] <- list(
        pu_id    = pu_ids[j],
        id2patch = conn$id2patch[nodes_lab],         # patch IDs in this component
        row_ptr  = newg$row_ptr,
        col_idx  = newg$col_idx
      )
    }
  }

  # Nodes in dropped components (labels in drop_labels) correspond
  # to patch IDs that must be removed from patch_dt and from the grid.
  drop_nodes   <- which(comp_id %in% drop_labels)
  drop_patches <- conn$id2patch[drop_nodes]

  list(
    csr_list     = csr_list,
    drop_patches = drop_patches,
    next_pu_id   = next_pu_id
  )
}

# ------------------------------------------------------------
# Compute PU-level log-values for scoring edge cells
# ------------------------------------------------------------
.compute_log_val <- function(pu_dt, params) {
  # pu_dt: data.table with at least (species, pu_id, pu_area_km2)
  # params: species-level parameters (joined by 'species'):
  #   - density
  #   - a_pred, b_pred    (shape parameters for the persistence model)
  #   - min_patch_size500 (c_th: effective threshold for PU area)
  #
  # Output:
  #   data.table(species, pu_id, log_val)
  # where log_val = log(∂S / ∂A_i) for the PU's contribution to multi-species persistence.
  #
  # This function is performance-critical because it is called every pruning step
  # and touches all PUs. We keep it fully vectorised:
  #   - no per-PU loops
  #   - minimal allocations
  #   - all math done in one pass.

  # Join species-level params onto each PU row.
  # This gives us a wide table with species, pu_id, area, and all model params.
  pu_data <- params[pu_dt, on = .(species)]

  # Shorthand vectors for readability and to avoid repeated $ lookups
  A    <- pu_data$pu_area_km2       # PU areas
  dens <- pu_data$density           # species density
  a    <- pu_data$a_pred            # model parameter a
  b    <- pu_data$b_pred            # model parameter b
  c_th <- pu_data$min_patch_size500 # PU threshold c_th
  sp   <- pu_data$species           # species ID for each PU

  # Assume all inputs are valid: A > c_th, dens > 0, etc.
  # This lets us skip checks and guard branches, which reduces overhead.

  # delta = A - c_th : margin above the PU-area threshold.
  delta    <- A - c_th
  logdelta <- log(delta)

  # log(a * dens^{-b})
  # Precompute this shared factor to avoid repeated log/exp in downstream expressions.
  log_a2 <- log(a) - b * log(dens)

  # y = log(a * dens^{-b} * delta^{-b})
  #    = log(a * dens^{-b}) - b * log(delta)
  y   <- log_a2 - b * logdelta
  e_y <- exp(y)                     # exp(y) is reused a few times

  # PU-level persistence probability:
  #   P_i = exp(-exp(y)) = exp(-e_y)
  P_i    <- exp(-e_y)
  log1mP <- log1p(-P_i)             # log(1 - P_i)

  # Sum log(1 - P_j) per species across all its PUs:
  #   sum_log1mP[species s] = Σ_j log(1 - P_j) over PUs j of species s
  # tapply is vectorised and fast enough here.
  sum_log1mP <- tapply(log1mP, sp, sum)

  # For PU i of species s, define:
  #   log Q_i = log ∏_{j≠i} (1 - P_j)
  #           = Σ_j log(1 - P_j) - log(1 - P_i)
  #           = sum_log1mP[s]    - log1mP[i]
  log_Qi <- sum_log1mP[sp] - log1mP

  # log dP_i/dA:
  # For your analytic form, we derived:
  #   dP_i/dA = a * dens^{-b} * b * delta^{-(b+1)} * exp(-exp(y)) * (stuff)
  # After simplifying, the log-derivative collapses to:
  #   log_dP = log(a * dens^{-b}) + log(b) - (b + 1)*log(delta) - e^y
  log_dP <- log_a2 + log(b) - (b + 1) * logdelta - e_y

  # Multi-species marginal loss:
  #   ∂S/∂A_i = (dP_i/dA) * Q_i
  # So on the log scale:
  #   log(∂S/∂A_i) = log_dP + log_Qi
  log_val <- log_dP + log_Qi

  # *** Single allowed sanity check ***
  # If anything goes non-finite, we stop hard, because this function is
  # central to scoring and we don't want to silently continue with NaNs.
  if (any(!is.finite(log_val))) {
    warning(".compute_log_val produced non-finite values in log_val.")
    stop("Non-finite log_val in .compute_log_val.")
  }

  # Return one row per PU, ready to join in prune_step_minimal().
  data.table(
    species = sp,
    pu_id   = pu_data$pu_id,
    log_val = log_val
  )
}
```

```{r}
prune_step_minimal <- function(
  iter,         # pruning iteration index within this stage
  n_remove,      # number of cells to remove in this pruning step
  patch_dt,      # patch table: (species, patch_id, pu_id, patch_area_km2)
  state_env,     # list of PU connectivity graphs (CSR), keyed by "species|pu_id"
  count_alive,   # integer vector: number of species present in each cell
  cs_vals,       # numeric vector: area (km^2) of each cell, aligned with count_alive
  params,        # species-level parameters (min_patch_size, min_patch_size500, etc.)
  vals_cache,    # list: vals_cache[[sp]][cell] = patch_id of species sp in that cell (or NA)
  patch_cells,   # list: patch_cells[[sp]][[patch_id]] = integer vector of cell indices
  rook_pairs_all # matrix [n_pairs x 2]: rook-adjacent cell index pairs
) {
  # We use the same species ordering whenever we loop over species-based lists.
  # This avoids repeated calls to names() and keeps the logic consistent and fast.
  species_layers <- names(vals_cache)

  # ------------------------------------------------------------------
  # 1) Identify edge cells (frontier)
  # ------------------------------------------------------------------
  # "alive" is TRUE where at least one species is present. This is the base
  # occupancy mask used for everything else.
  alive     <- count_alive > 0L

  # Indices of alive cells. Working in index space (rather than full vectors)
  # is both clearer and slightly faster.
  alive_idx <- which(alive)

  # alive_pos maps global cell index -> position in alive_idx (0 means not alive).
  # This lets us work in a compact "alive-space" when counting neighbors,
  # which is *much* faster than inspecting each cell's 4 neighbors in R loops.
  alive_pos            <- integer(length(alive))
  alive_pos[alive_idx] <- seq_along(alive_idx)

  # For every rook-adjacent pair (i, j), mark where *both* ends are alive.
  # This is vectorised across all adjacency pairs for speed.
  both_alive <- alive[rook_pairs_all[, 1]] & alive[rook_pairs_all[, 2]]

  # For the pairs where both cells are alive, pull the "from" cell’s position
  # in alive-space. These are the neighbor contributions we’ll count.
  pos_in_alive <- alive_pos[rook_pairs_all[both_alive, 1]]

  # Degree (0..4) of alive neighbors per alive cell. This tabulate call is
  # O(#adjacency_pairs), not O(#cells * 4), and there are no R-level loops.
  deg_alive <- tabulate(pos_in_alive, nbins = length(alive_idx))

  # Edge cells (the "frontier") are alive cells that do *not* have all 4
  # neighbors alive. Interior cells are ignored in this pruning step.
  edge_idx <- alive_idx[deg_alive < 4L]

  # If we cannot find at least n_remove edge cells, we declare the frontier
  # exhausted for this step. We skip all later work (scoring, updates, etc.),
  # which saves a lot of time when the landscape is nearly gone.
  if (length(edge_idx) < n_remove) {
    return(list(
      patch_dt            = patch_dt,  # unchanged
      state_env           = state_env, # unchanged
      count_alive         = count_alive,
      removed_indices     = integer(0L),
      changed_patch_areas = data.table(species = character(), patch_id = integer())
    ))
  }

  # Snapshot of cell occupancy *before* the step. We use this at the end to
  # identify which cells truly became empty (for removed_indices).
  count_before <- count_alive

  # ------------------------------------------------------------------
  # 2) PU areas + mapping
  # ------------------------------------------------------------------
  # For each (species, pu_id), compute its current total area by summing
  # its patch areas. This is the input to the marginal value function.
  pu_dt <- patch_dt[
    ,
    .(pu_area_km2 = sum(patch_area_km2)),
    by = .(species, pu_id)
  ]

  # Stable mapping from (species, patch_id) -> pu_id at the *start* of this step.
  # We keep this separate because patch_dt will be modified later; this snapshot
  # is needed for:
  #   - mapping patch_id -> PU marginal value
  #   - reconstructing which PUs changed later.
  patch_map_before <- patch_dt[, .(species, patch_id, pu_id)]

  # ------------------------------------------------------------------
  # 3) Score edge cells (multi-species log-sum-exp)
  # ------------------------------------------------------------------
  # Compute per-PU log-marginal values (log ∂S/∂A) for all PUs and species,
  # using species-level parameters. This is the core scoring for the algorithm.
  pu_val_dt <- .compute_log_val(pu_dt, params)

  # Attach PU log values to each patch through (species, pu_id), then reduce
  # to (species, patch_id, score). This gives us a patch-level score that
  # we can use to score cells via their patch IDs.
  patch2score_dt <- patch_map_before[
    pu_val_dt,
    on = .(species, pu_id),
    nomatch = 0L
  ][
    ,
    .(species, patch_id, score = log_val)
  ]

  # For each species, pack its patch_ids and corresponding scores into a small
  # list. This avoids repeated joins in the cell loop and lets us use fastmatch
  # for quick lookups: patch_id -> score.
  val_map <- lapply(
    split(patch2score_dt, patch2score_dt$species),
    function(d) list(pid = d$patch_id, score = d$score)
  )

  # Number of edge cells we need to score.
  edge_n <- length(edge_idx)

  # For each edge cell we maintain:
  #   m    = running max over species' log-values (for numerical stability)
  #   S    = sum exp(x - m) over species
  #   have = did this cell see at least one valid species score?
  # scores is filled at the end; initial -Inf serves as a sentinel.
  scores <- m <- rep(-Inf, edge_n)
  S      <- numeric(edge_n)
  have   <- logical(edge_n)

  # Loop over species that have scoring info.
  # This is the main multi-species accumulation of log-sum-exp.
  for (sp in names(val_map)) {
    # For species sp, get the patch ID at each edge cell. This is a simple
    # array lookup because vals_cache is indexed by cell.
    pid_vec <- vals_cache[[sp]][edge_idx]
    msp     <- val_map[[sp]]

    # Fast map patch_id -> row index in that species' scoring table.
    # fastmatch::fmatch is significantly faster than base::match.
    idx <- fastmatch::fmatch(pid_vec, msp$pid)

    # Look up log-marginal values for those patch IDs.
    x  <- msp$score[idx]
    ok <- is.finite(x)  # we only use finite entries

    if (any(ok)) {
      # io: indices of edge cells where this species contributes
      io <- which(ok)
      xo <- x[io]
      mo <- m[io]

      # "better" marks cells where this new species has a larger log-value
      # than the current max; we must rescale S in those cells.
      better <- xo > mo

      if (any(better)) {
        ib    <- io[better]
        # Rescale S to new max xo: S_new = S_old * exp(old_m - xo) + 1
        # (the "+1" is exp(xo - xo)).
        S[ib] <- S[ib] * exp(mo[better] - xo[better]) + 1
        m[ib] <- xo[better]
      }

      if (any(!better)) {
        inb <- io[!better]
        # For cells where xo <= current max, we just add exp(xo - mo).
        S[inb] <- S[inb] + exp(xo[!better] - mo[!better])
      }

      # Mark that these edge cells have at least one valid species
      # contribution; needed so we don't log(0) below.
      have[io] <- TRUE
    }
  }

  # Convert accumulated (m, S) into final multi-species scores:
  #
  #   log_sum_exp = m + log(S)
  #   score       = - log_sum_exp  (we minimize "penalty", so more negative
  #                                 log_sum_exp = larger score)
  #
  # Only apply where have == TRUE; under your assumptions, every edge cell
  # should have have == TRUE, but this mask keeps the math safe and cheap.
  scores[have] <- -(m[have] + log(S[have]))

  # We now have one score per edge cell. Because we already checked that
  # length(edge_idx) >= n_remove, we can safely request the top n_remove
  # scores without any further guards.
  s_sub <- scores
  n_sel <- n_remove

  # Find the cutoff score corresponding to the top n_sel (largest) entries
  # without fully sorting the vector. Rfast::nth is O(n), so this is much
  # cheaper than a full sort for large grids.
  cutoff <- Rfast::nth(
    s_sub,
    k            = n_sel,
    descending   = TRUE,
    index.return = FALSE
  )

  # Take all indices whose score >= cutoff. This may include more than n_sel
  # indices if there are ties at the cutoff.
  pick <- which(s_sub >= cutoff)

  # If we have more than n_sel candidates because of ties, we break ties
  # deterministically using:
  #   1) higher score first
  #   2) then smaller cell index (via edge_idx) as a stable tie-breaker.
  if (length(pick) > n_sel) {
    o    <- order(-s_sub[pick], edge_idx[pick])
    pick <- pick[o][seq_len(n_sel)]
  }

  # Translate picked positions in the edge list back to global cell indices.
  sel_idx <- edge_idx[pick]

  # ------------------------------------------------------------------
  # 4) Kill selected cells
  # ------------------------------------------------------------------
  # Removing all species from these cells is represented simply by setting
  # count_alive to 0. This is the cheapest way to keep the "alive" mask
  # in sync without touching per-species rasters here.
  count_alive[sel_idx] <- 0L

  # ------------------------------------------------------------------
  # 5) Attribute removed area to patches
  # ------------------------------------------------------------------
  # Extract cell areas of the removed cells. These are the amounts we’ll
  # subtract from patch areas.
  removed_cells_area <- cs_vals[sel_idx]

  # For each species, we:
  #   - get the patch_id at each removed cell
  #   - sum removed area per patch_id using rowsum() (fast C-level group by)
  #   - stack results across species.
  #
  # This uses only the removed cells and precomputed vals_cache, so it avoids
  # scanning the full grid and keeps the aggregation O(#removed_cells).
  removed_area_by_patch <- rbindlist(
    lapply(species_layers, function(sp) {
      pid <- vals_cache[[sp]][sel_idx]
      ok  <- !is.na(pid)
      if (!any(ok)) return(NULL)

      a <- rowsum(removed_cells_area[ok], pid[ok], reorder = FALSE)

      data.table(
        species      = sp,
        patch_id     = as.integer(rownames(a)),
        area_removed = as.numeric(a[, 1])
      )
    }),
    use.names = TRUE,
    fill      = TRUE
  )

  # ------------------------------------------------------------------
  # 6) Update patch areas & drop sub-viable patches (patch-level)
  # ------------------------------------------------------------------
  # Attach pu_id to removed-area data using the stable pre-step mapping.
  # We need pu_id to update patch_dt in a single in-place operation.
  dec <- removed_area_by_patch[
    patch_map_before,
    on = .(species, patch_id),
    nomatch = 0L
  ][
    ,
    .(species, patch_id, pu_id, area_removed)
  ]

  # Subtract removed area from each affected patch directly in patch_dt.
  # The i. prefix is standard data.table syntax for columns from "dec".
  patch_dt[dec,
           patch_area_km2 := patch_area_km2 - i.area_removed,
           on = .(species, patch_id, pu_id)]

  # Track which (species, patch_id) changed area. This lets us restrict
  # threshold checks to only those patches instead of re-scanning patch_dt.
  changed_patch_ids_step <- unique(dec[, .(species, patch_id)])

  # Drop patches whose area fell below the species-specific minimum
  # patch size. Because min_patch_size > 0, this also catches the patches
  # whose area went to zero or slightly negative (floating point noise).
  dropped_patches_all <- patch_dt[
    changed_patch_ids_step,
    on = .(species, patch_id)
  ][
    params,
    on = .(species)
  ][
    patch_area_km2 < min_patch_size,
    .(species, patch_id)
  ]

  # Remove those patches from patch_dt; they no longer exist in the system.
  patch_dt <- patch_dt[!dropped_patches_all, on = .(species, patch_id)]

  # ------------------------------------------------------------------
  # 7) Update PU components & accumulate patch drops for cells
  # ------------------------------------------------------------------
  # pending_drop[sp] will hold patch_ids of species sp that should be
  # removed from the cell-level representation at the end of the step.
  pending_drop <- setNames(vector("list", length(species_layers)), species_layers)

  # Initialize pending_drop with all patches dropped at the patch level.
  dp <- split(dropped_patches_all$patch_id, dropped_patches_all$species)
  for (sp in names(dp)) {
    pending_drop[[sp]] <- c(pending_drop[[sp]], dp[[sp]])
  }

  # Only PUs that lost at least one patch need their connectivity recomputed.
  # We find those PUs by merging dropped_patches_all with the stable
  # pre-step mapping patch_map_before.
  aff_pairs <- merge(
    dropped_patches_all,
    patch_map_before,
    by = c("species", "patch_id")
  )

  # For each species, update PUs that lost patches.
  for (sp in unique(aff_pairs$species)) {
    sp_rows <- aff_pairs$species == sp
    by_pu   <- split(aff_pairs$patch_id[sp_rows], aff_pairs$pu_id[sp_rows])

    # New components (if PUs split) get pu_id values starting after the
    # current maximum pu_id for that species.
    next_pu_id <- if (any(patch_dt$species == sp)) {
      max(patch_dt$pu_id[patch_dt$species == sp])
    } else {
      0L
    }

    # Species-specific PU area threshold for components.
    thr_pu    <- params[sp, min_patch_size500]
    # Patch -> area map for this species, used to build per-PU vectors quickly.
    pa_map_sp <- patch_dt[species == sp, .(patch_id, patch_area_km2)]

    for (pu in names(by_pu)) {
      key  <- paste0(sp, "|", pu)
      conn <- state_env[[key]]
      if (is.null(conn)) next

      id2patch <- conn$id2patch
      dead_ids <- by_pu[[pu]]
      N        <- length(id2patch)

      # alive_nodes marks which nodes (patches) remain in this PU.
      alive_nodes <- rep(TRUE, N)
      alive_nodes[id2patch %in% dead_ids] <- FALSE

      # Build patch_area vector aligned with id2patch indices.
      pa  <- numeric(N)
      idx <- fastmatch::fmatch(id2patch, pa_map_sp$patch_id)
      ok  <- !is.na(idx)
      pa[ok] <- pa_map_sp$patch_area_km2[idx[ok]]

      # Let .update_pu_components:
      #   - split the PU into connected components
      #   - drop components with area < thr_pu
      #   - assign new pu_id values to surviving components
      #   - return updated CSR graphs and additional patches to drop.
      res <- .update_pu_components(
        conn        = conn,
        alive_nodes = alive_nodes,
        patch_area  = pa,
        thr         = thr_pu,
        next_pu_id  = next_pu_id
      )
      next_pu_id <- res$next_pu_id

      # Any patches belonging to sub-threshold components must be dropped.
      drop_ids_comp <- res$drop_patches
      if (length(drop_ids_comp)) {
        pending_drop[[sp]] <- c(pending_drop[[sp]], drop_ids_comp)
        patch_dt <- patch_dt[!(species == sp & patch_id %in% drop_ids_comp)]
      }

      # Replace the original PU CSR object with the new component graphs.
      csr_list <- res$csr_list
      if (!length(csr_list)) {
        # Entire PU disappeared.
        state_env[[key]] <- NULL
      } else {
        for (j in seq_along(csr_list)) {
          cobj <- csr_list[[j]]

          if (j == 1L) {
            # First component reuses the original key.
            state_env[[key]] <- list(
              species  = sp,
              pu_id    = cobj$pu_id,
              id2patch = cobj$id2patch,
              row_ptr  = cobj$row_ptr,
              col_idx  = cobj$col_idx
            )
          } else {
            # Additional components get new keys.
            new_key <- paste0(sp, "|", cobj$pu_id)
            state_env[[new_key]] <- list(
              species  = sp,
              pu_id    = cobj$pu_id,
              id2patch = cobj$id2patch,
              row_ptr  = cobj$row_ptr,
              col_idx  = cobj$col_idx
            )
          }

          # Update patch_dt so patches in this component now reference
          # the correct (possibly new) pu_id.
          patch_dt[species == sp & patch_id %in% cobj$id2patch,
                   pu_id := cobj$pu_id]
        }
      }
    }
  }

  # ------------------------------------------------------------------
  # 8) Drop sub-viable PUs (min_patch_size500, PU-level)
  # ------------------------------------------------------------------
  # At PU level, we only need to check PUs that:
  #   - contain patches that lost area, or
  #   - contained patches dropped entirely.
  cand_patches <- unique(
    rbindlist(
      list(
        removed_area_by_patch[, .(species, patch_id)],
        dropped_patches_all
      ),
      use.names = TRUE,
      fill      = TRUE
    ),
    by = c("species", "patch_id")
  )

  # PUs (before this step) that contained any of those candidate patches.
  aff_pus_before <- unique(
    patch_map_before[
      cand_patches,
      on = .(species, patch_id),
      nomatch = 0L
    ][
      ,
      .(species, pu_id)
    ],
    by = c("species", "pu_id")
  )

  # All patches (before) that belonged to those PUs.
  aff_patches_all <- patch_map_before[
    aff_pus_before,
    on = .(species, pu_id),
    nomatch = 0L
  ][
    ,
    .(species, patch_id)
  ]

  # Surviving patches (after this step) from that set.
  aff_patches_after <- patch_dt[
    aff_patches_all,
    on = .(species, patch_id),
    nomatch = 0L
  ]

  # PUs that still exist after patch-level pruning.
  cand_pus_after <- unique(
    aff_patches_after[, .(species, pu_id)],
    by = c("species", "pu_id")
  )

  # Sum remaining patch areas within those PUs.
  pu_agg <- patch_dt[
    cand_pus_after,
    .(pu_area_km2 = sum(patch_area_km2)),
    on  = .(species, pu_id),
    by  = .EACHI
  ]

  # Join min_patch_size500 and drop PUs whose total area is below threshold.
  pu_check   <- params[pu_agg, on = .(species)]
  dropped_pu <- pu_check[pu_area_km2 < min_patch_size500,
                         .(species, pu_id)]

  # Any PU that fails the PU threshold is removed entirely:
  #   - enqueue its patches for cell-level cleanup
  #   - remove its CSR entry
  #   - remove its patches from patch_dt.
  for (i in seq_len(nrow(dropped_pu))) {
    sp  <- dropped_pu$species[i]
    pu  <- dropped_pu$pu_id[i]
    key <- paste0(sp, "|", pu)

    pat_ids <- patch_dt[species == sp & pu_id == pu, patch_id]
    if (length(pat_ids)) {
      pending_drop[[sp]] <- c(pending_drop[[sp]], pat_ids)
    }

    state_env[[key]] <- NULL
    patch_dt <- patch_dt[!(species == sp & pu_id == pu)]
  }

  # ------------------------------------------------------------------
  # 9) Apply all pending patch drops to count_alive
  # ------------------------------------------------------------------
  # Drop all patches that were removed at patch/PU level from the cell-level
  # occupancy representation by decrementing count_alive at their cells.
  # We use patch_cells mappings to avoid scanning the entire grid.
  for (sp in names(pending_drop)) {
    ids    <- unique(pending_drop[[sp]])  # unique() prevents double-decrement
    pcs_sp <- patch_cells[[sp]]
    for (pid in ids) {
      cells <- pcs_sp[[as.character(pid)]]
      if (!length(cells)) next
      hit   <- cells[count_alive[cells] > 0L]
      if (length(hit)) {
        count_alive[hit] <- count_alive[hit] - 1L
      }
    }
  }

  # ------------------------------------------------------------------
  # 10) Final bookkeeping
  # ------------------------------------------------------------------
  # Cells that were alive before and are now empty are counted as fully
  # removed this step. This is the summary the orchestrator likely cares about.
  removed_indices <- which(count_before > 0L & count_alive == 0L)

  # Patches whose area changed this step:
  #   - patches that lost some area (even if they survived)
  #   - patches that were dropped entirely.
  # This is useful for any downstream bookkeeping or diagnostics.
  changed_patch_areas <- unique(
    rbindlist(
      list(
        removed_area_by_patch[, .(species, patch_id)],
        dropped_patches_all
      ),
      use.names = TRUE,
      fill      = TRUE
    ),
    by = c("species", "patch_id")
  )

  # Lightweight log: uses values already computed, so cost is negligible.
  .log_console(
    "prune_step",
    "iter=%d, edge=%d, selected=%d, removed_cells=%d, changed_patches=%d, dropped_patches=%d, dropped_pus=%d",
    as.integer(iter),
    length(edge_idx),
    length(sel_idx),
    length(removed_indices),
    nrow(changed_patch_areas),
    nrow(dropped_patches_all),
    nrow(dropped_pu)
  )

  list(
    patch_dt            = patch_dt,
    state_env           = state_env,
    count_alive         = count_alive,
    removed_indices     = removed_indices,
    changed_patch_areas = changed_patch_areas
  )
}
```

# run_pruning_orchestrator

```{r}
# ------------------------------------------------------------
# Orchestrator for repeated pruning iterations
# ------------------------------------------------------------
run_pruning_orchestrator <- function(
  k,
  n_remove,
  patch_dt,
  state_env,
  count_alive,
  patch_stack,
  cs_vals,
  rook_pairs_all,
  params,
  output_dir,
  stage_iter
) {
  # Stage-level log: cheap scalar summary of this pruning stage,
  # including basic state info for patch_dt, state_env, and count_alive.
  n_patches_dt   <- nrow(patch_dt)
  n_species_dt   <- if (n_patches_dt) data.table::uniqueN(patch_dt$species) else 0L
  n_pus_dt       <- if (n_patches_dt) data.table::uniqueN(patch_dt[, .(species, pu_id)])    else 0L
  n_pus_stateenv <- length(state_env)
  n_alive_cells  <- sum(count_alive > 0L)
  max_sp_cell    <- if (length(count_alive)) max(count_alive) else 0L

  .log_console(
    "pruning_stage",
    paste(
      "Pruning stage_%04d start:",
      "k=%d, n_remove=%d, n_species_layers=%d,",
      "n_patches_dt=%d, n_species_dt=%d, n_pus_dt=%d, n_pus_stateenv=%d,",
      "alive_cells=%d, max_sp_per_cell=%d"
    ),
    as.integer(stage_iter),
    as.integer(k),
    as.integer(n_remove),
    length(names(patch_stack)),
    as.integer(n_patches_dt),
    as.integer(n_species_dt),
    as.integer(n_pus_dt),
    as.integer(n_pus_stateenv),
    as.integer(n_alive_cells),
    as.integer(max_sp_cell)
  )

  # ------------------------------------------------------------------
  # 1) Precompute static cell → patch mappings for this stage
  #
  # These are *purely spatial* mappings derived from patch_stack. They
  # do not change between iterations, so we compute them once here and
  # reuse them in every call to prune_step_minimal().
  #
  # This reduces runtime substantially compared to recomputing them
  # inside each pruning step.
  # ------------------------------------------------------------------

  # Extract all patch IDs into a dense matrix:
  #   rows   = cells
  #   cols   = species layers (one per raster layer)
  # This is the cheapest way to pull all layer values out of patch_stack.
  patch_vals_all <- terra::values(patch_stack, mat = TRUE)
  colnames(patch_vals_all) <- names(patch_stack)
  species_layers <- colnames(patch_vals_all)

  # Cache a per-species vector of patch IDs in cell order:
  #   vals_cache[[sp]][cell] = patch_id (or NA if no patch of that species)
  #
  # prune_step_minimal() uses these vectors for both:
  #   - scoring edge cells (mapping each cell to its patch_id),
  #   - aggregating removed cell area to patches.
  #
  # Caching avoids repeated `terra::values()` or raster access inside
  # the inner pruning loop.
  vals_cache <- lapply(seq_along(species_layers), function(j) patch_vals_all[, j])
  names(vals_cache) <- species_layers

  # Precompute patch → cells mapping:
  #   patch_cells[[sp]][[patch_id]] = integer vector of cell indices.
  #
  # prune_step_minimal() uses this to update `count_alive` when whole
  # patches or PUs are dropped, without scanning all cells.
  #
  # We build this once here, instead of rebuilding in every iteration.
  patch_cells <- lapply(seq_along(species_layers), function(j) {
    vals <- vals_cache[[j]]
    idx  <- which(!is.na(vals))            # cells where this species has a patch
    split(idx, vals[idx], drop = TRUE)     # split cell indices by patch_id
  })
  names(patch_cells) <- species_layers

  # ------------------------------------------------------------------
  # 2) Accumulators across iterations
  #
  # We want to return:
  #   - the union of all removed cells across iterations,
  #   - the union of all patches whose area changed at least once.
  #
  # We therefore keep per-iteration outputs and merge them at the end.
  # Preallocating lists of length k is slightly more efficient (and
  # simpler) than growing them dynamically.
  # ------------------------------------------------------------------
  removed_list <- vector("list", k)  # per-iteration removed cell indices
  changed_list <- vector("list", k)  # per-iteration changed (species, patch_id)
  n_iter_run   <- 0L                # number of iterations actually executed

  # ------------------------------------------------------------------
  # 3) Main pruning loop
  #
  # At each iteration:
  #   - call prune_step_minimal() with the current state,
  #   - record which cells were removed and which patches changed,
  #   - write a per-iteration removed-cell mask (if anything changed),
  #   - update the shared state (patch_dt, state_env, count_alive),
  #   - stop early if no cells were removed (frontier exhausted).
  #
  # This loop is the driver for the core pruning behaviour.
  # ------------------------------------------------------------------
  for (iter in seq_len(k)) {
    # One pruning step: does all heavy lifting (edge detection, scoring,
    # patch/PU updates, CSR updates, count_alive updates).
    step_out <- prune_step_minimal(
      iter           = iter,
      n_remove       = n_remove,
      patch_dt       = patch_dt,
      state_env      = state_env,
      count_alive    = count_alive,
      cs_vals        = cs_vals,
      params         = params,
      vals_cache     = vals_cache,
      patch_cells    = patch_cells,
      rook_pairs_all = rook_pairs_all
    )

    # Record that this iteration ran, and store its outputs
    n_iter_run <- n_iter_run + 1L
    removed_list[[n_iter_run]] <- step_out$removed_indices
    changed_list[[n_iter_run]] <- step_out$changed_patch_areas

    # Per-iteration removal mask:
    #   - Only written if any cells were removed, to avoid useless I/O.
    #   - This is an important behavioural output for diagnostics /
    #     visualization of the pruning trajectory, but the check itself
    #     also reduces runtime by skipping empty rasters.
    if (length(step_out$removed_indices) > 0L) {
      # Use the first patch_stack layer as a geometry template.
      mask <- terra::setValues(patch_stack[[1]], NA_integer_)
      mask[step_out$removed_indices] <- 1L

      fn <- file.path(
        output_dir,
        sprintf(
          "removed_mask_pruning_stage_%04d_iter_%03d.tif",
          stage_iter,
          iter
        )
      )
      terra::writeRaster(mask, filename = fn, overwrite = TRUE)
    }

    # Update shared state so the next iteration starts from the new
    # configuration. This is essential for correct behaviour: each
    # iteration must "see" the results of all previous pruning.
    patch_dt    <- step_out$patch_dt
    state_env   <- step_out$state_env
    count_alive <- step_out$count_alive

    # Early stop condition:
    #   If prune_step_minimal removes zero cells but n_remove > 0
    #   (assumed), then the edge frontier is exhausted and there’s no
    #   point in continuing further iterations. Stopping here saves
    #   runtime while preserving the intended behaviour (stop when
    #   nothing more can be pruned).
    if (!length(step_out$removed_indices)) {
      break
    }
  }

  # ------------------------------------------------------------------
  # 4) Consolidate results across iterations
  #
  # We now collapse per-iteration records into:
  #   - a single vector of all removed cell indices,
  #   - a single table of all patches that changed area.
  #
  # Both unions are part of the intended API behaviour.
  # ------------------------------------------------------------------
  # All cells removed in any iteration, deduplicated
  removed_indices_all <- unique(
    unlist(removed_list[seq_len(n_iter_run)], use.names = FALSE)
  )

  # All patches that changed area in any iteration:
  #   - rbindlist() stacks per-iteration tables,
  #   - unique(by = ...) ensures we return each (species, patch_id) once.
  changed_patch_areas_all <- unique(
    data.table::rbindlist(
      changed_list[seq_len(n_iter_run)],
      use.names = TRUE
    ),
    by = c("species", "patch_id")
  )
  
  # Enforce: candidates must still exist in the final patch_dt
  changed_patch_areas_all <- changed_patch_areas_all[
    patch_dt[, .(species, patch_id)],
    on = .(species, patch_id),
    nomatch = 0L
  ]

  # ------------------------------------------------------------------
  # 5) Frontier status & final "alive" mask
  #
  # Definition:
  #   - Frontier is considered exhausted if the last iteration removed
  #     no cells (length == 0).
  #
  # Behaviour:
  #   - When exhausted, we also write a final mask summarising which
  #     cells are still alive (count_alive > 0) after the last step.
  #
  # The alive mask is a high-value summary output, and computing it is
  # cheap since count_alive is already in memory.
  # ------------------------------------------------------------------
  frontier_exhausted <- !length(removed_list[[n_iter_run]])

  if (frontier_exhausted) {
    # Build a final "alive" mask:
    #   - NA where dead,
    #   - 1 where count_alive > 0.
    alive_mask  <- terra::setValues(patch_stack[[1]], NA_integer_)
    alive_cells <- which(count_alive > 0L)
    alive_mask[alive_cells] <- 1L

    fn_alive <- file.path(
      output_dir,
      sprintf(
        "alive_mask_pruning_stage_%04d_iter_%03d_final.tif",
        stage_iter,
        n_iter_run
      )
    )
    terra::writeRaster(alive_mask, filename = fn_alive, overwrite = TRUE)
  }

  # Final state + bookkeeping that upstream code may need:
  #   - patch_dt / state_env / count_alive: updated system state,
  #   - removed_indices_all: all cells that ever became empty,
  #   - changed_patch_areas_all: all patches whose area was modified,
  #   - frontier_exhausted: whether pruning terminated because nothing
  #     more could be removed.
  list(
    patch_dt            = patch_dt,
    state_env           = state_env,
    count_alive         = count_alive,
    removed_indices     = removed_indices_all,
    changed_patch_areas = changed_patch_areas_all,
    frontier_exhausted  = frontier_exhausted
  )
}
```

# apply_patch_fragmentation_updates

```{r}
# apply_patch_fragmentation_updates
# 
# High-level role in the pipeline:
# --------------------------------
# Given:
#   - patch_stack: per-species patch-ID rasters *after* pruning,
#   - patch_dt: table of patches (species, patch_id, pu_id, area),
#   - state_env: per-(species, PU) connectivity graphs (CSR),
#   - changed_patch_areas: patches whose area changed in pruning,
#   - cs_vals: per-cell area,
#   - params: species-specific thresholds,
#   - count_alive: number of species present per cell,
#
# This function:
#   1. Detects fragmentation of patches whose area changed.
#   2. Applies patch-level thresholds (min_patch_size).
#   3. Applies PU-level thresholds (min_patch_size500).
#   4. Updates:
#       - patch_stack (rasters),
#       - patch_dt (patch table),
#       - state_env (CSR graphs),
#       - count_alive (per-cell species count),
#       - list of patch_ids needing distance-based recheck.
#
# Design goals:
#   - Correctly reflect pruning-induced fragmentation.
#   - Restrict expensive operations (clump, CSR rebuild) to *only*
#     affected species, patches, and PUs.
#   - Avoid repeated deep copies of rasters.
#   - Avoid building huge intermediate tables if possible.
#   - Emit only cheap-but-useful summary logs for Pass 1 and Pass 3.

apply_patch_fragmentation_updates <- function(
  patch_stack,         # SpatRaster AFTER pruning (patch IDs per species)
  patch_dt,            # data.table: (species, patch_id, pu_id, patch_area_km2), keyed on (species, patch_id)
  state_env,           # named list of CSR objects per PU ("species|pu_id")
  changed_patch_areas, # data.table / data.frame: (species, patch_id) whose area changed in pruning
  cs_vals,             # numeric: per-cell area (km^2), aligned to global cell index
  params,              # data.table keyed by species, with min_patch_size, min_patch_size500
  count_alive          # integer vector: per-cell alive-species count (after pruning)
) {
  ## ==========================================================
  ## GLOBAL SETUP
  ## ==========================================================

  # Species names / layer names in the raster stack.
  species_layers <- names(patch_stack)

  # Precompute species-specific thresholds as named vectors.
  # This makes threshold lookup O(1) by 'sp' (no joins inside loops).
  min_patch_by_species    <- setNames(params$min_patch_size,    params$species)
  min_patch500_by_species <- setNames(params$min_patch_size500, params$species)

  # Alive-cell mask: TRUE where at least one species is present.
  # We use this to:
  #   - avoid clump() work in totally empty areas,
  #   - ensure we don't waste time clumping dead cells.
  alive_flag <- !is.na(count_alive) & count_alive > 0L

  # Working copy of count_alive. We mutate this when patches/PUs disappear.
  # This lets callers keep the original count_alive if needed.
  count_work <- count_alive

  # Candidate patches: only those whose area changed in pruning.
  # This is the key shortcut: we *only* do fragmentation checks and
  # CSR work for these patches, not for all patches.
  cand_dt <- data.table::as.data.table(changed_patch_areas)[, .(species, patch_id)]

  # Per-species containers for everything that later passes need.
  # Using lists keeps memory light and avoids repeated joins.
  species_updates         <- vector("list", length(species_layers))
  names(species_updates)  <- species_layers
  area_updates_list       <- setNames(vector("list", length(species_layers)), species_layers)
  pu_threshold_check_list <- setNames(vector("list", length(species_layers)), species_layers)

  ## ==========================================================
  ## PASS 1: PER-SPECIES FRAGMENTATION ON RASTERS
  ##
  ## For each species:
  ##   - Restrict raster to alive cells.
  ##   - Compute a single clump() on a cropped sub-raster containing
  ##     only candidate patches (not the full landscape).
  ##   - For each candidate patch:
  ##       * Detect whether it fragmented (>= 2 clumps).
  ##       * Drop small fragments (< min_patch_size).
  ##       * Create new patch IDs for surviving fragments.
  ##       * Track which PUs lost area (for PU-level threshold checks).
  ##       * Track patches needing distance-based recheck.
  ##
  ## Performance highlights:
  ##   - Exactly one clump() per species (no per-patch clump()).
  ##   - Clump computed on a cropped sub-raster (smaller extent).
  ##   - All downstream work is vectorized where possible.
  ## ==========================================================

  for (sp in species_layers) {
    # Candidate patch IDs for this species.
    cand_ids <- cand_dt[species == sp, unique(patch_id)]

    # If pruning didn't touch this species' patches, we skip all raster work.
    if (!length(cand_ids)) {
      # NEW: for unchanged species, capture the original single-layer SpatRaster
      # in layer_sp_final so PASS 4 can rebuild the stack purely from
      # species_updates and we don't depend on the original multi-layer stack.
      species_updates[[sp]] <- list(
        patches_to_drop = integer(0L),
        new_patch_rows  = NULL,
        desc_rows       = NULL,
        removed_only    = NULL,
        recheck_ids     = integer(0L),
        layer_sp_final  = patch_stack[[sp]]  # NEW
      )
      next
    }

    # Original patch-ID layer for this species.
    lyr0  <- patch_stack[[sp]]
    # Extract cell values once into a vector (fast to mutate in R).
    vals0 <- terra::values(lyr0, mat = TRUE)[, 1]

    # Restrict to alive cells only: dead cells can't contribute to
    # any surviving patches, so we treat them as NA.
    # This reduces the area that clump() has to process.
    vals0[!alive_flag] <- NA_integer_
    lyr0_alive <- terra::setValues(lyr0, vals0)

    # Working copy of patch IDs; we'll overwrite this as fragments are
    # assigned new IDs or removed.
    vals_new <- vals0

    # Per-species buffers that will eventually become small data.tables.
    # Keeping them as lists of small pieces avoids repeated rbinds
    # inside the heavy loops.
    new_rows_buf          <- list()          # new patch_dt rows for new fragments
    desc_buf              <- list()          # (pu, old_patch, new_patch) mapping
    removed_only_buf      <- list()          # (pu, old_patch) that vanished
    drop_lookup_ids       <- integer(0L)     # patch IDs to remove from patch_dt
    recheck_ids           <- integer(0L)     # patch IDs needing distance recheck
    area_updates_sp       <- list()          # (species, patch_id, area_km2)
    pu_threshold_check_sp <- list()          # (species, pu_id) that lost area

    # Next available patch_id for this species (for new fragments).
    # We compute this once so we can assign new IDs without repeated
    # max() calls or lookups.
    sp_pids <- patch_dt[species == sp, patch_id]
    max_pid <- if (length(sp_pids)) max(sp_pids) else 0L

    # Species-specific minimum patch area threshold.
    th_patch <- min_patch_by_species[[sp]]

    # Map candidate patches to the indices of their cells.
    #   - idx_all: indices of all cells belonging to any candidate patch.
    #   - pid_idx: named list mapping patch_id -> vector of cell indices.
    idx_all <- which(!is.na(vals0) & vals0 %in% cand_ids)
    pid_idx <- split(idx_all, vals0[idx_all], drop = TRUE)

    # Compute a single clump() on a cropped sub-raster containing only
    # those cells. This massively reduces both memory and time compared
    # to clumping the entire species layer.
    all_cells <- unlist(pid_idx, use.names = FALSE)
    ext_sub   <- terra::ext(lyr0_alive, cells = all_cells)
    lyr_sub   <- terra::crop(lyr0_alive, ext_sub, snap = "near")

    cl_sub      <- terra::rast(
      fasterRaster::clump(fasterRaster::fast(lyr_sub), diagonal = FALSE)
    )
    cl_sub_vals <- terra::values(cl_sub, mat = TRUE)[, 1]

    # Build a mapping:
    #   global cell index (in lyr0_alive) -> cell index in cl_sub
    # so we can get clump IDs for any set of patch cells with a simple
    # vector lookup instead of rerunning raster operations.
    xy_all        <- terra::xyFromCell(lyr0_alive, all_cells)
    sub_cells_all <- terra::cellFromXY(cl_sub, xy_all)
    names(sub_cells_all) <- as.character(all_cells)

    # Helper: fetch clump IDs for a vector of global cell indices.
    clump_fetch <- function(pid_cells) {
      cl_sub_vals[sub_cells_all[as.character(pid_cells)]]
    }

    # -------------------------
    # Per-patch fragmentation
    # -------------------------
    for (pid in cand_ids) {
      # PU containing this patch (cheap keyed lookup in patch_dt).
      pu_id_old <- patch_dt[.(sp, pid), pu_id]

      # Cells for this patch ID (within alive geometry).
      pid_cells <- pid_idx[[as.character(pid)]]

      # Clump labels for these cells (in the cropped clump raster).
      subc  <- clump_fetch(pid_cells)
      ucomp <- unique(subc[!is.na(subc)])

      # Case A: patch remained a single clump.
      #   - Geometry might have changed (shape), but it's still contiguous.
      #   - We mark it for distance-based recheck and skip all fragmentation logic.
      if (length(ucomp) <= 1L) {
        recheck_ids <- c(recheck_ids, as.integer(pid))
        next
      }

      # Case B: true fragmentation (>= 2 clumps).
      # We compute area per clump using cs_vals (per-cell area).
      ok <- !is.na(subc)
      area_tab <- rowsum(
        cs_vals[pid_cells][ok],
        subc[ok],
        reorder = FALSE
      )

      # keep_tab: table of (clump_label, area) sorted by area descending.
      keep_tab <- data.frame(
        comp_raw  = as.integer(rownames(area_tab)),
        area      = as.numeric(area_tab[, 1]),
        row.names = NULL
      )
      keep_tab <- keep_tab[order(-keep_tab$area), , drop = FALSE]

      # Apply minimum patch size threshold: only clumps above th_patch survive.
      keep_tab <- keep_tab[keep_tab$area >= th_patch, , drop = FALSE]

      # Wipe the original patch label from all cells of this patch.
      # Surviving clumps will be assigned new (or reused) patch IDs below.
      vals_new[pid_cells] <- NA_integer_

      # If no clump survives, the patch disappears entirely.
      if (!nrow(keep_tab)) {
        drop_lookup_ids <- c(drop_lookup_ids, pid)

        if (!is.na(pu_id_old)) {
          # Record that this (pu, patch) vanished completely.
          removed_only_buf[[length(removed_only_buf) + 1L]] <-
            data.table::data.table(
              pu_id        = pu_id_old,
              old_patch_id = as.integer(pid)
            )

          # This PU lost area; we will recheck its PU-area threshold in Pass 2b.
          pu_threshold_check_sp[[length(pu_threshold_check_sp) + 1L]] <-
            data.table::data.table(species = sp, pu_id = pu_id_old)
        }

        # Species removed from these cells entirely → decrement count_work.
        hit <- pid_cells[count_work[pid_cells] > 0L]
        count_work[hit] <- count_work[hit] - 1L
        next
      }

      # If some clumps survive:
      #   - keep_ids_raw: clumps we keep as patches.
      #   - drop_ids_raw: clumps we drop (< threshold).
      keep_ids_raw <- keep_tab$comp_raw
      drop_ids_raw <- setdiff(ucomp, keep_ids_raw)

      # For dropped clumps:
      #   - species disappears from those cells,
      #   - PU loses some area (trigger PU recheck later).
      if (length(drop_ids_raw)) {
        drop_cells <- pid_cells[subc %in% drop_ids_raw]
        hit <- drop_cells[count_work[drop_cells] > 0L]
        count_work[hit] <- count_work[hit] - 1L

        if (!is.na(pu_id_old)) {
          pu_threshold_check_sp[[length(pu_threshold_check_sp) + 1L]] <-
            data.table::data.table(species = sp, pu_id = pu_id_old)
        }
      }

      # Assign patch IDs to surviving clumps:
      #   - largest fragment keeps old patch_id,
      #   - additional fragments get fresh patch IDs.
      if (nrow(keep_tab) > 1L) {
        new_ids <- c(pid, seq(max_pid + 1L, length.out = nrow(keep_tab) - 1L))
        max_pid <- max_pid + (length(new_ids) - 1L)
      } else {
        new_ids <- pid
      }

      # Map clump labels -> patch IDs and write them back into vals_new.
      comp_to_new <- setNames(as.integer(new_ids), as.character(keep_tab$comp_raw))
      keep_mask   <- subc %in% keep_tab$comp_raw
      vals_new[pid_cells[keep_mask]] <-
        unname(comp_to_new[as.character(subc[keep_mask])])

      # Record updated areas for surviving fragments.
      area_updates_sp[[length(area_updates_sp) + 1L]] <-
        data.table::data.table(
          species        = sp,
          patch_id       = as.integer(new_ids),
          patch_area_km2 = as.numeric(keep_tab$area)
        )

      # If the patch lives in a PU and produced *new* fragments, we need
      # new rows in patch_dt for those extra fragments, inheriting pu_id.
      if (!is.na(pu_id_old) && length(new_ids) >= 2L) {
        new_rows_buf[[length(new_rows_buf) + 1L]] <-
          data.table::data.table(
            species        = sp,
            patch_id       = as.integer(new_ids[-1]),
            pu_id          = pu_id_old,
            patch_area_km2 = as.numeric(keep_tab$area[-1])
          )
      }

      # Descendant mapping (for CSR rebuild in Pass 3):
      #   (pu_id, old_patch_id) → new_patch_id(s).
      if (!is.na(pu_id_old)) {
        desc_buf[[length(desc_buf) + 1L]] <-
          data.table::data.table(
            pu_id        = pu_id_old,
            old_patch_id = as.integer(pid),
            new_patch_id = as.integer(new_ids)
          )
      }

      # All surviving fragments (including the old ID) need distance-based rechecks.
      recheck_ids <- c(recheck_ids, as.integer(new_ids))
    } # end per-patch loop for species sp
    
    # NEW: drop per-species clump objects as soon as we're done with them
    # to reduce memory pressure before the next species.
    rm(cl_sub_vals, sub_cells_all)
    gc()

    # Collapse per-species buffers into compact tables (or NULL).
    new_patch_rows <- if (length(new_rows_buf)) {
      data.table::rbindlist(new_rows_buf, use.names = TRUE)
    } else NULL

    desc_rows <- if (length(desc_buf)) {
      data.table::rbindlist(desc_buf, use.names = TRUE)
    } else NULL

    removed_only <- if (length(removed_only_buf)) {
      data.table::rbindlist(removed_only_buf, use.names = TRUE)
    } else NULL

    area_updates_list[[sp]] <- if (length(area_updates_sp)) {
      data.table::rbindlist(area_updates_sp, use.names = TRUE, fill = TRUE)
    } else NULL

    pu_threshold_check_list[[sp]] <- if (length(pu_threshold_check_sp)) {
      data.table::rbindlist(pu_threshold_check_sp, use.names = TRUE, fill = TRUE)
    } else NULL

    # Record all updates for this species; later passes will consume this.
    species_updates[[sp]] <- list(
      patches_to_drop = unique(as.integer(drop_lookup_ids)),
      new_patch_rows  = new_patch_rows,
      desc_rows       = desc_rows,
      removed_only    = removed_only,
      recheck_ids     = unique(as.integer(recheck_ids)),
      layer_sp_final  = terra::setValues(lyr0_alive, vals_new)
    )
    
    # NEW: immediately free per-species big objects (alive copy, value
    # vectors, and indexing structures) for species that were actually
    # processed, to keep the working set small.
    rm(lyr0_alive, vals0, vals_new, idx_all, pid_idx, all_cells)
    gc()
  } # end PASS 1 species loop

  ## ==========================================================
  ## PASS 1 CONSOLIDATION + SUMMARY LOG
  ##
  ## Here we:
  ##   - Combine per-species area updates and PU flags into single tables.
  ##   - Emit a single summary log using cheap scalar summaries.
  ## ==========================================================

  # NEW: at this point, every species has its final layer stored in
  # species_updates[[sp]]$layer_sp_final (either modified or original).
  # The original multi-layer patch_stack object is no longer needed
  # structurally and can be dropped to simplify the object graph before
  # we rebuild the stack in PASS 4.
  rm(patch_stack)  # NEW
  gc()             # NEW

  # Combine per-species area updates into one table (if any).
  area_updates_pieces <- Filter(Negate(is.null), area_updates_list)
  area_updates <- if (length(area_updates_pieces)) {
    data.table::rbindlist(area_updates_pieces, use.names = TRUE, fill = TRUE)
  } else NULL

  # Combine per-species PU threshold flags into one table (if any).
  pu_threshold_pieces <- Filter(Negate(is.null), pu_threshold_check_list)
  pu_threshold_check <- if (length(pu_threshold_pieces)) {
    data.table::rbindlist(pu_threshold_pieces, use.names = TRUE, fill = TRUE)
  } else NULL

  # Cheap scalar summaries for logging:
  n_species_touched <- sum(vapply(
    species_updates,
    function(su) !is.null(su$layer_sp_final),
    logical(1L)
  ))

  total_cand_patches <- nrow(cand_dt)
  
  # NEW: we no longer need cand_dt beyond this point; keep only the
  # scalar summary to free its memory early.
  rm(cand_dt)
  gc()

  total_dropped_patches <- sum(vapply(
    species_updates,
    function(su) length(su$patches_to_drop),
    integer(1L)
  ))

  total_new_fragments <- sum(vapply(
    species_updates,
    function(su) if (is.null(su$new_patch_rows)) 0L else nrow(su$new_patch_rows),
    integer(1L)
  ))

  total_recheck_patches <- sum(vapply(
    species_updates,
    function(su) length(su$recheck_ids),
    integer(1L)
  ))

  n_pu_flagged_total <- if (!is.null(pu_threshold_check)) {
    data.table::uniqueN(pu_threshold_check$pu_id)
  } else 0L

  # PASS 1 summary log: describes how many patches were considered,
  # how many died, how many fragments were created, and how many PUs
  # will need PU-level rechecks. All quantities are derived from
  # already-built objects (no extra heavy work).
  .log_console(
    "fragmentation_pass1",
    "[%s] Frag PASS1 complete: species_touched=%d, cand_patches=%d, dropped_patches=%d, new_fragments=%d, recheck_patches=%d, pu_flagged=%d.",
    format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
    n_species_touched,
    total_cand_patches,
    total_dropped_patches,
    total_new_fragments,
    total_recheck_patches,
    n_pu_flagged_total
  )

  ## ==========================================================
  ## PASS 2: patch_dt UPDATES (PATCH-LEVEL)
  ##
  ## This is pure table work:
  ##   - Remove vanished patches.
  ##   - Update areas for surviving fragments.
  ##   - Append new rows for newly created fragment IDs.
  ##   All raster work has already been done in Pass 1.
  ## ==========================================================

  # Remove patches that disappeared during fragmentation.
  for (sp in names(species_updates)) {
    rid <- species_updates[[sp]]$patches_to_drop
    if (length(rid)) {
      patch_dt <- patch_dt[!(species == sp & patch_id %in% rid)]
    }
  }

  # Apply area updates for surviving fragments.
  if (!is.null(area_updates)) {
    patch_dt[area_updates,
             patch_area_km2 := i.patch_area_km2,
             on = .(species, patch_id)]
  }

  # Append new patch rows for additional fragments.
  new_rows_components <- Filter(
    Negate(is.null),
    lapply(species_updates, `[[`, "new_patch_rows")
  )
  if (length(new_rows_components)) {
    new_rows_all <- data.table::rbindlist(new_rows_components, use.names = TRUE, fill = TRUE)
    # unique() guards against any accidental duplication (cheap at this scale).
    patch_dt <- data.table::rbindlist(
      list(patch_dt, unique(new_rows_all)),
      use.names = TRUE,
      fill      = TRUE
    )
  }

  ## ==========================================================
  ## PASS 2b: PU-LEVEL THRESHOLD CHECKS (min_patch_size500)
  ##
  ## Only PUs that actually lost area (due to dropped clumps or fully
  ## vanished patches) are rechecked. If a PU's total area falls below
  ## its threshold:
  ##   - remove its patches from the raster and patch_dt,
  ##   - remove its CSR object,
  ##   - decrement count_work where species vanished.
  ##
  ## This avoids rescanning all PUs and keeps work proportional to change.
  ## ==========================================================

  if (!is.null(pu_threshold_check)) {
    pu_threshold_check <- unique(pu_threshold_check)

    for (sp in unique(pu_threshold_check$species)) {
      thr_pu    <- min_patch500_by_species[[sp]]
      pu_ids_sp <- pu_threshold_check[species == sp, unique(pu_id)]

      # Current total PU area for these (species, pu_id) pairs after Pass 2.
      pu_rows_now <- patch_dt[
        species == sp & pu_id %in% pu_ids_sp,
        .(pu_area_km2 = sum(patch_area_km2)),
        by = .(species, pu_id)
      ]

      # PUs that now fail the area threshold.
      to_drop <- pu_rows_now[pu_area_km2 < thr_pu, .(species, pu_id)]

      if (nrow(to_drop)) {
        # Get the current patch-ID raster values for this species.
        vals_sp_final <- terra::values(
          species_updates[[sp]]$layer_sp_final, mat = TRUE
        )[, 1]

        # For each PU below threshold:
        for (j in seq_len(nrow(to_drop))) {
          pu <- to_drop$pu_id[j]

          # All patch IDs in this PU for this species.
          patch_ids <- patch_dt[species == sp & pu_id == pu, patch_id]

          # Cells where these patch IDs occur: species is fully removed.
          idx <- which(!is.na(vals_sp_final) & vals_sp_final %in% patch_ids)
          hit <- idx[count_work[idx] > 0L]
          count_work[hit] <- count_work[hit] - 1L
          vals_sp_final[idx] <- NA_integer_

          # Drop PU from patch_dt and its CSR object from state_env.
          patch_dt <- patch_dt[!(species == sp & pu_id == pu)]
          key <- paste0(sp, "|", pu)
          state_env[[key]] <- NULL
        }

        # Write back updated raster values for this species.
        species_updates[[sp]]$layer_sp_final <-
          terra::setValues(species_updates[[sp]]$layer_sp_final, vals_sp_final)
      }
    }
  }

  ## ==========================================================
  ## PASS 3: CSR REBUILD FOR PUs THAT CHANGED MEMBERSHIP
  ##
  ## For PUs where:
  ##   - patches fragmented (old_id → new_id(s)), or
  ##   - patches vanished entirely,
  ## we rebuild or adjust their CSR graphs so that:
  ##   - topology remains consistent with new patch IDs,
  ##   - PUs with 0 or 1 patch get trivial CSR representations,
  ##   - fragmentation creates a "clique" among fragments of a patch,
  ##   - edges between old patches are inherited by their descendants.
  ##
  ## Optimization strategy:
  ##   - "Cheap path" when there are no new IDs in the PU:
  ##        * Only areas changed: update patch_area and comp_area in place.
  ##        * Some patches removed: restrict the CSR using .rebuild_csr().
  ##   - "Full path" only when new patch IDs appear in the PU.
  ##   - We build adjacency using integer vectors and deduplicate once,
  ##     avoiding heavy data.table joins.
  ## ==========================================================

  total_species_with_pu_updates <- 0L  # # species where any PU was touched
  total_pu_touched              <- 0L  # total # of PUs touched
  total_pu_cheap                <- 0L  # # of PUs using cheap path
  total_pu_full                 <- 0L  # # of PUs using full rebuild
  total_pu_drop                 <- 0L  # # of PUs that lost all patches

  for (sp in names(species_updates)) {
    su <- species_updates[[sp]]

    # PUs touched for this species: those with fragmentation (desc_rows)
    # or completely removed patches (removed_only).
    pu_ids <- unique(c(
      if (!is.null(su$desc_rows))    su$desc_rows$pu_id,
      if (!is.null(su$removed_only)) su$removed_only$pu_id
    ))
    pu_ids <- pu_ids[!is.na(pu_ids)]
    n_pu_touched <- length(pu_ids)

    if (!n_pu_touched) {
      next
    }

    total_species_with_pu_updates <- total_species_with_pu_updates + 1L
    total_pu_touched              <- total_pu_touched + n_pu_touched

    # Species-wide patch-area map (after Pass 2).
    # This is reused for all PUs of this species.
    pa_map_sp <- patch_dt[species == sp, .(patch_id, patch_area_km2)]

    for (pu in pu_ids) {
      key      <- paste0(sp, "|", pu)
      conn_old <- state_env[[key]]
      # PU may have already been removed in Pass 2b (or never existed).
      if (is.null(conn_old)) next

      # Old CSR data for this PU (before fragmentation updates).
      id2patch_old <- as.integer(conn_old$id2patch)
      row_ptr_old  <- as.integer(conn_old$row_ptr)
      col_idx_old  <- as.integer(conn_old$col_idx)

      # Current patch IDs in this PU after Pass 2 / 2b.
      pu_patch_now <- patch_dt[species == sp & pu_id == pu, patch_id]

      ## ---------- Case 0: PU lost all patches ----------
      if (!length(pu_patch_now)) {
        state_env[[key]] <- NULL
        total_pu_drop <- total_pu_drop + 1L
        next
      }

      ## ---------- Case 1: exactly one patch in this PU ----------
      # Trivial 1-node CSR: no edges, comp_area = patch_area.
      if (length(pu_patch_now) == 1L) {
        patch_id_final <- pu_patch_now[1L]

        idx_area <- fastmatch::fmatch(patch_id_final, pa_map_sp$patch_id)
        pa_final <- pa_map_sp$patch_area_km2[idx_area]

        state_env[[key]] <- list(
          species    = sp,
          pu_id      = pu,
          id2patch   = as.integer(patch_id_final),
          patch2id   = 1L,
          row_ptr    = c(0L, 0L),       # no edges
          col_idx    = integer(0L),
          alive      = TRUE,
          patch_area = pa_final,
          comp_id    = 1L,
          comp_area  = pa_final
        )

        total_pu_cheap <- total_pu_cheap + 1L
        next
      }

      ## ---------- Multi-node PUs ----------
      removed_ids <- setdiff(id2patch_old, pu_patch_now)
      # True if this PU now contains any patch IDs that weren't in
      # the original CSR (these are new fragments).
      has_new_ids <- any(!(pu_patch_now %in% id2patch_old))

      ## ---------- Cheap path: no new patch IDs ----------
      if (!has_new_ids) {
        total_pu_cheap <- total_pu_cheap + 1L

        if (!length(removed_ids)) {
          # Only patch areas changed; topology is unchanged.
          # Just refresh patch_area and comp_area in place.
          idx <- fastmatch::fmatch(id2patch_old, pa_map_sp$patch_id)
          patch_area_vec <- pa_map_sp$patch_area_km2[idx]

          state_env[[key]]$patch_area <- patch_area_vec
          state_env[[key]]$comp_area  <- sum(patch_area_vec)
          next
        } else {
          # Some patches removed, but no new patches created:
          # restrict CSR to surviving nodes and update areas.
          keep_idx <- which(!(id2patch_old %in% removed_ids))

          newg         <- .rebuild_csr(row_ptr_old, col_idx_old, keep_idx)
          id2patch_new <- as.integer(id2patch_old[keep_idx])

          idx <- fastmatch::fmatch(id2patch_new, pa_map_sp$patch_id)
          patch_area_vec <- pa_map_sp$patch_area_km2[idx]

          state_env[[key]] <- list(
            species    = sp,
            pu_id      = pu,
            id2patch   = id2patch_new,
            patch2id   = as.integer(seq_along(id2patch_new)),
            row_ptr    = newg$row_ptr,
            col_idx    = newg$col_idx,
            alive      = rep(TRUE, length(id2patch_new)),
            patch_area = patch_area_vec,
            comp_id    = rep(1L, length(id2patch_new)),  # single component PU
            comp_area  = sum(patch_area_vec)
          )
          next
        }
      }

      ## ---------- Full rebuild: PU has new patch IDs ----------
      total_pu_full <- total_pu_full + 1L
      N <- length(id2patch_old)

      ## ---- 1) Build descendant map D_map[[i]] ----
      # D_map[[i]] = set of final patch IDs in this PU that descended
      # from original node i (patch id2patch_old[i]).
      desc_pu <- if (!is.null(su$desc_rows)) su$desc_rows[pu_id == pu] else NULL

      # Split desc_pu by old_patch_id for O(1) lookup.
      desc_split <- if (!is.null(desc_pu) && nrow(desc_pu) > 0L) {
        split(desc_pu$new_patch_id, desc_pu$old_patch_id)
      } else {
        list()
      }

      # present_now[i] TRUE if original patch id2patch_old[i] still has
      # *some* surviving descendant in this PU.
      present_now <- !is.na(fastmatch::fmatch(id2patch_old, pu_patch_now))

      D_map <- vector("list", N)
      names(D_map) <- as.character(id2patch_old)

      for (i in seq_len(N)) {
        pid0 <- id2patch_old[i]

        if (!present_now[i]) {
          # This original patch has no surviving descendants in this PU.
          D_map[[i]] <- integer(0L)
          next
        }

        d_i <- if (length(desc_split)) desc_split[[as.character(pid0)]] else NULL

        if (is.null(d_i) || !length(d_i)) {
          # No explicit descendants recorded:
          #   - either no fragmentation, or
          #   - fragmentation with only one surviving fragment = pid0.
          D_map[[i]] <- as.integer(pid0)
        } else {
          D_map[[i]] <- as.integer(d_i)
        }
      }

      ## ---- 2) Final patch IDs and index map ----
      # Collect all descended patch IDs and build a 1..K index map.
      patches_final <- sort(unique(unlist(D_map, use.names = FALSE)))
      K             <- length(patches_final)
      pid_to_idx    <- setNames(seq_len(K), as.character(patches_final))

      ## ---- 3) Build edge set as integer vectors (u, v) ----
      #
      # Target: build undirected adjacency among:
      #   - Sibling edges: fragments from the same original patch.
      #   - Inherited edges: descendants along original edges (i, j).
      #
      # We construct edges as integer vectors and deduplicate once,
      # which is much lighter than incremental list-growing in loops.

      # 3a) Sibling edges: all pairs of descendants from same original node.
      sib_u_list <- vector("list", N)
      sib_v_list <- vector("list", N)
      ks         <- 0L

      for (i in seq_len(N)) {
        d <- D_map[[i]]
        if (length(d) > 1L) {
          nodes <- unname(pid_to_idx[as.character(d)])

          if (length(nodes) == 2L) {
            # Fast path for 2-node clique: single edge.
            ks <- ks + 1L
            sib_u_list[[ks]] <- nodes[1L]
            sib_v_list[[ks]] <- nodes[2L]
          } else {
            # For >2 nodes, create all 2-combinations.
            comb <- utils::combn(nodes, 2L)
            ks <- ks + 1L
            sib_u_list[[ks]] <- comb[1L, ]
            sib_v_list[[ks]] <- comb[2L, ]
          }
        }
      }

      if (ks > 0L) {
        u_sib <- unlist(sib_u_list[seq_len(ks)], use.names = FALSE)
        v_sib <- unlist(sib_v_list[seq_len(ks)], use.names = FALSE)
      } else {
        u_sib <- v_sib <- integer(0L)
      }

      # 3b) Inherited edges: descendants across edges (i, j) in old CSR.
      inh_u_list <- vector("list", N)
      inh_v_list <- vector("list", N)
      ke         <- 0L

      for (i in seq_len(N)) {
        di <- D_map[[i]]
        if (!length(di)) next

        # Neighbours of node i in the old CSR.
        s <- row_ptr_old[i] + 1L
        e <- row_ptr_old[i + 1L]
        if (e < s) next

        nbrs <- col_idx_old[s:e]
        # Use only j > i to avoid double edges (symmetry will be added later).
        nbrs <- nbrs[nbrs > i]
        if (!length(nbrs)) next

        di_idx <- unname(pid_to_idx[as.character(di)])

        for (j in nbrs) {
          dj <- D_map[[j]]
          if (!length(dj)) next

          dj_idx <- unname(pid_to_idx[as.character(dj)])

          ni <- length(di_idx)
          nj <- length(dj_idx)

          # Cross-product: all descendants of i are neighbours with
          # all descendants of j.
          ke <- ke + 1L
          inh_u_list[[ke]] <- rep.int(di_idx, nj)
          inh_v_list[[ke]] <- rep(dj_idx, each = ni)
        }
      }

      if (ke > 0L) {
        u_inh <- unlist(inh_u_list[seq_len(ke)], use.names = FALSE)
        v_inh <- unlist(inh_v_list[seq_len(ke)], use.names = FALSE)
      } else {
        u_inh <- v_inh <- integer(0L)
      }

      # Combine sibling + inherited edges into (u_all, v_all).
      if (length(u_sib) || length(u_inh)) {
        u_all <- c(u_sib, u_inh)
        v_all <- c(v_sib, v_inh)
      } else {
        u_all <- v_all <- integer(0L)
      }

      ## ---- 4) Deduplicate edges and build CSR adjacency ----

      if (length(u_all)) {
        # Canonicalize undirected edges: enforce u <= v.
        u_can <- pmin(u_all, v_all)
        v_can <- pmax(u_all, v_all)

        # Drop self-loops.
        keep_nv <- (u_can != v_can)
        u_can   <- u_can[keep_nv]
        v_can   <- v_can[keep_nv]

        if (length(u_can)) {
          # Deduplicate edges using integer key.
          # key_int is unique for each (u, v) if K is within int range.
          key_int <- u_can + (v_can - 1L) * K

          ord <- order(key_int)
          key_int <- key_int[ord]
          u_can   <- u_can[ord]
          v_can   <- v_can[ord]

          uniq  <- !duplicated(key_int)
          u_can <- u_can[uniq]
          v_can <- v_can[uniq]

          # Build symmetric adjacency: for each undirected (u, v),
          # add both u->v and v->u.
          u_sym <- c(u_can, v_can)
          v_sym <- c(v_can, u_can)

          adj_new <- split(v_sym, u_sym)

          # Full adjacency list 1..K, with empty integer vectors where needed.
          adj_full <- vector("list", K)
          if (length(adj_new)) {
            for (nm in names(adj_new)) {
              idx_node <- as.integer(nm)
              adj_full[[idx_node]] <- adj_new[[nm]]
            }
          }

          # Sort + unique neighbours per node, then build CSR row_ptr/col_idx.
          lens <- integer(K)
          for (k in seq_len(K)) {
            nb <- adj_full[[k]]
            if (length(nb)) {
              nb <- sort(unique(nb))
              adj_full[[k]] <- nb
              lens[k] <- length(nb)
            } else {
              adj_full[[k]] <- integer(0L)
              lens[k] <- 0L
            }
          }

          row_ptr_new <- c(0L, cumsum(lens))
          col_idx_new <- if (sum(lens) > 0L) {
            as.integer(unlist(adj_full, use.names = FALSE))
          } else {
            integer(0L)
          }
        } else {
          # All edges were self-loops (dropped) → edgeless graph.
          row_ptr_new <- rep(0L, K + 1L)
          col_idx_new <- integer(0L)
        }
      } else {
        # No edges at all (very rare but possible).
        row_ptr_new <- rep(0L, K + 1L)
        col_idx_new <- integer(0L)
      }

      ## ---- 5) Attach patch areas and store final CSR for this PU ----
      idx_area <- fastmatch::fmatch(patches_final, pa_map_sp$patch_id)
      patch_area_vec <- pa_map_sp$patch_area_km2[idx_area]

      state_env[[key]] <- list(
        species    = sp,
        pu_id      = pu,
        id2patch   = as.integer(patches_final),
        patch2id   = as.integer(seq_along(patches_final)),
        row_ptr    = as.integer(row_ptr_new),
        col_idx    = col_idx_new,
        alive      = rep(TRUE, length(patches_final)),
        patch_area = patch_area_vec,
        comp_id    = rep(1L, length(patches_final)),   # treat PU as one component
        comp_area  = sum(patch_area_vec)
      )
    } # end loop over PUs for species sp
  } # end PASS 3 species loop

  # PASS 3 summary log: cheap scalar counts summarising CSR rebuild work.
  .log_console(
    "fragmentation_pass3",
    "[%s] Frag PASS3 complete: species_with_PU_updates=%d, PUs_touched=%d, PUs_cheap=%d, PUs_full=%d, PUs_dropped=%d.",
    format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
    total_species_with_pu_updates,
    total_pu_touched,
    total_pu_cheap,
    total_pu_full,
    total_pu_drop
  )

  ## ==========================================================
  ## PASS 4: REBUILD patch_stack ONCE (RASTER)
  ##
  ## To avoid deep-copy behaviour from repeated [[<- on a SpatRaster,
  ## we:
  ##   - assemble per-species layers in a plain list,
  ##   - build a new SpatRaster stack with a single terra::rast() call.
  ##
  ## We also drop large intermediates and call gc() to reduce memory
  ## pressure before the big allocation.
  ## ==========================================================

  rm(area_updates_list, pu_threshold_check_list, area_updates_pieces, pu_threshold_pieces)
  gc()

  new_layers <- vector("list", length(species_layers))
  for (i in seq_along(species_layers)) {
    sp <- species_layers[i]
    lyr_final <- species_updates[[sp]]$layer_sp_final

    if (is.null(lyr_final)) {
      # NEW: guardrail – every species should now have a layer_sp_final.
      stop("Internal error in apply_patch_fragmentation_updates: missing layer_sp_final for species ", sp)
    }

    # NEW: ensure each single-layer raster carries its species name
    # before stacking. This is cheap (acts on one layer at a time) and
    # avoids a global names<- on the full stack, which would trigger
    # a deep copy of all layers.
    if (!identical(names(lyr_final), sp)) {
      names(lyr_final) <- sp
    }

    new_layers[[i]] <- lyr_final
  }

  # Build the new multi-layer stack from the per-species layers.
  # NEW: we deliberately *do not* call names(patch_stack) <- species_layers
  # here, because that global renaming was previously triggering a
  # std::bad_alloc via x@pntr$deepcopy() on very large stacks.
  patch_stack <- terra::rast(new_layers)

  # Cells that went from "at least one species present" to "no species".
  # These are useful for downstream bookkeeping in the pipeline.
  removed_idx <- which(count_alive > 0L & count_work == 0L)

  ## ==========================================================
  ## PASS 5: COLLECT patch_ids_to_recheck FOR DISTANCE STAGE
  ##
  ## Gather all patches whose geometry changed (or were created)
  ## to pass to the distance-based connectivity stage.
  ##
  ## We intersect with patch_dt to ensure we don't include IDs that
  ## were removed by PU-level pruning.
  ## ==========================================================

  recheck_all <- data.table::rbindlist(
    lapply(names(species_updates), function(sp) {
      data.table::data.table(
        species  = sp,
        patch_id = as.integer(species_updates[[sp]]$recheck_ids)
      )
    }),
    use.names = TRUE,
    fill      = TRUE
  )

  data.table::setkey(recheck_all, species, patch_id)
  recheck_all <- unique(
    recheck_all[
      patch_dt[, .(species, patch_id)],
      on = .(species, patch_id),
      nomatch = 0L
    ]
  )

  .log_console(
    "fragmentation_stage",
    "[%s] Frag stage complete: pass1_cand=%d, pass1_dropped=%d, pass1_new_frag=%d, pass1_recheck=%d, pass1_pu_flagged=%d, pass3_pu_touched=%d, pass3_pu_cheap=%d, pass3_pu_full=%d, pass3_pu_drop=%d, removed_cells=%d, recheck_patches=%d.",
    format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
    total_cand_patches,
    total_dropped_patches,
    total_new_fragments,
    total_recheck_patches,
    n_pu_flagged_total,
    total_pu_touched,
    total_pu_cheap,
    total_pu_full,
    total_pu_drop,
    length(removed_idx),
    nrow(recheck_all)
  )
  
  ## ==========================================================
  ## FINAL RETURN
  ##
  ## We return all updated structures required by downstream steps.
  ## ==========================================================

  list(
    patch_stack          = patch_stack,
    patch_dt             = patch_dt,
    state_env            = state_env,
    count_alive          = count_work,
    patch_ids_to_recheck = recheck_all,
    removed_indices      = removed_idx
  )
}
```

# update_connectivity_after_distance

```{r}
# ------------------------------------------------------------
# 5. Distance-based Connectivity Update (minimal, no alive01)
#   Assumes:
#     • sf::sf_use_s2(TRUE) was set once elsewhere;
#     • patch_stack layers are already in a geographic CRS
#       compatible with sf::st_distance (e.g. lon/lat).
#
# Goal of this stage:
#   • Enforce species-specific maximum dispersal distances between patches.
#   • If distance breaks connectivity within a PU, split it into components
#     and drop small components below the min_patch_size500 threshold.
#   • Keep patch_dt, state_env and count_alive consistent with these changes.
#
# Design goals:
#   • Only touch patches whose geometry / IDs changed (and their neighbours).
#   • Reuse raster values per species (cache) to avoid repeated terra::values().
#   • Restrict polygon building to a tight bounding box around candidate cells.
#   • Update existing CSR graphs in-place instead of rebuilding everything.
#   • Emit a single cheap global log summarising the distance stage.
# ------------------------------------------------------------
update_connectivity_after_distance <- function(
  patch_stack,          # SpatRaster: patch IDs per species (after fragmentation)
  patch_dt,             # data.table: species, patch_id, pu_id, patch_area_km2
  state_env,            # list of CSR graphs per PU (key: "species|pu_id")
  patch_ids_to_recheck, # data.table: (species, patch_id) whose geometry/ID changed
  params,               # data.table: species, dispersal_dist (km), min_patch_size500
  count_alive           # integer: per-cell count of species present (before distance step)
) {
  ## ----------------------------------------------------------
  ## 1. Pre-compute indices, thresholds, and helpers
  ## ----------------------------------------------------------

  # Key and index patch_dt for fast joins by (species, patch_id) and (species, pu_id).
  # This supports:
  #   - fast mapping from patches to PUs,
  #   - fast PU-area lookups when rebuilding CSR components.
  data.table::setkey(patch_dt, species, patch_id)
  data.table::setindex(patch_dt, species, pu_id)

  # Working copy of per-cell alive-species counts.
  # We decrement this as patches are dropped so that:
  #   • behaviour: final count_alive reflects distance-induced removals;
  #   • memory/runtime: we avoid recomputing counts from scratch.
  count_work <- as.integer(count_alive)

  # Per-species dispersal distances (km -> m) and PU min-area thresholds.
  # These are used in the distance test and when dropping small components.
  disp_m_by_species <- setNames(params$dispersal_dist * 1000, params$species)
  min_pu_by_species <- setNames(params$min_patch_size500,    params$species)

  # Normalise patch_ids_to_recheck to a clean (species, patch_id) table
  # and key it by the same columns as patch_dt.
  # This is the minimal set of patches whose geometry changed and thus may
  # affect distance connectivity.
  recheck_dt <- data.table::as.data.table(patch_ids_to_recheck)[, .(species, patch_id)]
  data.table::setkey(recheck_dt, species, patch_id)

  # Per-species raster-value cache:
  #   • behaviour: we always read the same layer values used in fragmentation;
  #   • runtime: we avoid repeated terra::values() calls inside loops;
  #   • memory: each species' values are stored once, not rebuilt per PU.
  vals_cache <- new.env(parent = emptyenv())
  get_layer_vals <- function(sp) {
    key <- paste0("vals__", sp)
    if (!exists(key, envir = vals_cache, inherits = FALSE)) {
      v <- terra::values(patch_stack[[sp]], mat = TRUE)[, 1]
      assign(key, as.integer(v), envir = vals_cache)
    }
    get(key, envir = vals_cache, inherits = FALSE)
  }

  # PUs that contain patches needing distance re-check:
  #   • behaviour: we only operate on PUs where something changed;
  #   • runtime: dramatically reduces work in late stages when most PUs are stable;
  #   • memory: fewer polygons and CSR structures need to be touched.
  recheck_pus <- patch_dt[
    recheck_dt,
    on = .(species, patch_id)
  ][
    !is.na(pu_id),
    .(species, pu_id)
  ]
  recheck_pus <- unique(recheck_pus)

  # We mutate a working copy of the CSR environment, leaving the input list
  # conceptually unchanged outside this function.
  state_env_work <- state_env

  # Global counters for a single, cheap summary log.
  # All of these are built from existing per-species scalars and require
  # only integer additions (no extra passes over large data):
  #   • Stage 1 (candidate selection): species_touched, PUs_touched,
  #     changed_patches, cand_patches.
  #   • Stage 3 (graph update): edges_checked, edges_dropped,
  #     dropped_patches, removed_PUs.
  #   • Overall effect: alive_cells_before/after and total cells_lost.
  total_species_touched    <- 0L
  total_pus_touched        <- 0L
  total_changed_patches    <- 0L
  total_candidate_patches  <- 0L
  total_edges_checked      <- 0L
  total_edges_dropped      <- 0L
  total_patches_dropped    <- 0L
  total_pus_removed        <- 0L

  ## ----------------------------------------------------------
  ## 2. Main loop over species with PUs to re-check
  ## ----------------------------------------------------------
  for (sp in unique(recheck_pus$species)) {
    pu_ids_sp      <- unique(recheck_pus[species == sp, pu_id])
    changed_ids_sp <- unique(recheck_dt[species == sp, patch_id])

    # If this species has no relevant PUs or no changed patches, skip it.
    if (!length(pu_ids_sp) || !length(changed_ids_sp)) next

    # --- Cheap stats for later global logging (all either free or very cheap) ----
    # These are per-species scalars that we will accumulate into the global
    # counters once we know this species actually went through the distance
    # update pipeline (i.e. had at least one candidate patch).
    n_pu_sp      <- length(pu_ids_sp)
    n_changed_sp <- length(changed_ids_sp)

    # Per-species counters (used only for the global summary log).
    cand_patch_ids_sp  <- integer(0L)
    edges_checked_sp   <- 0L
    edges_dropped_sp   <- 0L
    dropped_patches_sp <- 0L
    pus_removed_sp     <- 0L

    ## ------------------------------------------------------
    ## Step 1: Candidate patch IDs (changed + neighbours)
    ##
    ## We don’t need to re-evaluate all edges:
    ##   • Only edges incident to changed patches can change distance.
    ##   • We also need the neighbour patches to compute those distances.
    ## This keeps complexity closer to "changed boundary size" than
    ## "total graph size".
    ## ------------------------------------------------------
    cand_list <- vector("list", length(pu_ids_sp))
    li        <- 0L

    for (pu in pu_ids_sp) {
      key  <- paste0(sp, "|", pu)
      conn <- state_env_work[[key]]
      if (is.null(conn)) next  # PU may have been removed earlier in this function

      id2patch <- as.integer(conn$id2patch)
      row_ptr  <- as.integer(conn$row_ptr)
      col_idx  <- as.integer(conn$col_idx)

      # Patches in this PU that changed geometry / ID
      changed_ids_pu <- intersect(changed_ids_sp, id2patch)
      if (!length(changed_ids_pu)) next

      changed_idx <- match(changed_ids_pu, id2patch)

      # Neighbours of changed nodes (using CSR row_ptr/col_idx)
      nbr_idx <- unique(unlist(lapply(changed_idx, function(u) {
        s <- row_ptr[u] + 1L
        e <- row_ptr[u + 1L]
        if (e >= s) as.integer(col_idx[s:e]) else integer(0L)
      })))

      # Candidate nodes = changed nodes + their neighbours
      cand_nodes <- sort(unique(c(changed_idx, nbr_idx)))
      if (length(cand_nodes)) {
        li <- li + 1L
        cand_list[[li]] <- id2patch[cand_nodes]
      }
    }

    # If no candidates exist for this species, there is nothing to do for
    # distance connectivity; skip without touching the global counters.
    if (!li) next

    cand_patch_ids_sp <- sort(unique(
      unlist(cand_list[seq_len(li)], use.names = FALSE)
    ))

    ## ------------------------------------------------------
    ## Step 2: Build polygons for candidate patches
    ##
    ## We:
    ##   • mask the species raster to only the candidate patch IDs;
    ##   • restrict to a bounding box over cells that contain those IDs;
    ##   • convert that sub-raster into polygons;
    ##
    ## This reduces:
    ##   • runtime: fewer cells fed into terra::as.polygons();
    ##   • memory: smaller intermediate rasters and sf objects.
    ## ------------------------------------------------------
    lv_full <- get_layer_vals(sp)

    # Keep only cells belonging to candidate patches
    idx_match   <- match(lv_full, cand_patch_ids_sp, nomatch = 0L)
    masked_vals <- rep(NA_integer_, length(lv_full))
    masked_vals[idx_match > 0L] <- lv_full[idx_match > 0L]

    # If no cells belong to candidates (defensive), skip species
    idx_all <- which(!is.na(masked_vals))
    if (!length(idx_all)) next

    base_rast   <- patch_stack[[sp]]
    masked_rast <- terra::setValues(base_rast, masked_vals)

    # Tight extent around candidate cells → smaller polygonisation window.
    ext_sub     <- terra::ext(base_rast, cells = idx_all)
    masked_sub  <- terra::crop(masked_rast, ext_sub, snap = "near")

    # Build polygons of candidate patches; we assume raster is already in
    # an appropriate geographic CRS for sf::st_distance().
    poly       <- terra::as.polygons(masked_sub, values = TRUE, dissolve = TRUE)
    poly_sf_sp <- sf::st_as_sf(poly)
    
    # NEW: masked raster objects no longer needed
    rm(masked_rast, masked_sub)
    gc()
    
    if (!nrow(poly_sf_sp)) next  # Nothing to do if no candidate polygons

    # Identify non-geometry column with patch IDs and standardise its name
    gcol <- attr(poly_sf_sp, "sf_column")
    pidc <- setdiff(names(poly_sf_sp), gcol)[1]
    data.table::setnames(poly_sf_sp, pidc, "patch_id")

    # Drop artefacts with missing patch_id
    poly_sf_sp <- poly_sf_sp[!is.na(poly_sf_sp$patch_id), ]
    
    # NEW: immediately pull out just what we need and drop the heavy sf object
    geom_sp <- sf::st_geometry(poly_sf_sp)
    pid_vec <- as.integer(poly_sf_sp$patch_id)
    pid_to_poly_sp <- setNames(
      seq_len(length(pid_vec)),
      as.character(pid_vec)
    )
    
    # Drop data frame + original SpatVector, keep only geometry + mapping
    poly_sf_sp$patch_id <- NULL
    rm(poly_sf_sp, poly, pid_vec)
    gc()

    # Species-specific dispersal distance in meters
    disp_m <- disp_m_by_species[[sp]]

    # Next available PU id for this species (for new components created
    # by splitting disconnected PUs); 0 fallback handles degenerate cases.
    next_pu_id_sp <- max(patch_dt[species == sp, pu_id], na.rm = TRUE)
    if (!is.finite(next_pu_id_sp)) next_pu_id_sp <- 0L

    ## ------------------------------------------------------
    ## Step 3: Per-PU distance filtering and PU splitting
    ##
    ## For each PU:
    ##   • identify edges incident to changed patches;
    ##   • drop edges that exceed dispersal distance;
    ##   • recompute connected components and drop sub-threshold PUs;
    ##   • update CSR graphs and patch_dt accordingly.
    ##
    ## This preserves the original behaviour while touching only the
    ## subgraph affected by geometry changes.
    ## ------------------------------------------------------
    for (pu in pu_ids_sp) {
      key  <- paste0(sp, "|", pu)
      conn <- state_env_work[[key]]
      if (is.null(conn)) next

      id2patch <- as.integer(conn$id2patch)
      N        <- length(id2patch)
      row_ptr  <- as.integer(conn$row_ptr)
      col_idx  <- as.integer(conn$col_idx)

      # Changed patches that belong to this PU
      changed_ids_pu <- intersect(changed_ids_sp, id2patch)
      if (!length(changed_ids_pu)) next

      changed_idx <- match(changed_ids_pu, id2patch)

      # Build adjacency list from CSR representation
      adj <- vector("list", N)
      for (i in seq_len(N)) {
        s <- row_ptr[i] + 1L
        e <- row_ptr[i + 1L]
        adj[[i]] <- if (e >= s) as.integer(col_idx[s:e]) else integer(0L)
      }

      # Collect directed edges (i, j) incident to changed nodes
      pi_list <- vector("list", length(changed_idx))
      pj_list <- vector("list", length(changed_idx))
      ei      <- 0L

      for (idx_u in seq_along(changed_idx)) {
        u  <- changed_idx[idx_u]
        nb <- adj[[u]]
        if (length(nb)) {
          ei <- ei + 1L
          pi_list[[ei]] <- rep.int(u, length(nb))
          pj_list[[ei]] <- nb
        }
      }

      # If no edges touch changed patches, PU connectivity is unaffected
      if (!ei) next

      pairs_i <- unlist(pi_list[seq_len(ei)], use.names = FALSE)
      pairs_j <- unlist(pj_list[seq_len(ei)], use.names = FALSE)

      # Unique directed edges (i, j) to test
      pairs <- data.table::data.table(i = pairs_i, j = pairs_j)
      pairs <- unique(pairs)

      # Count edges we actually examined for this species (for logging).
      edges_checked_sp <- edges_checked_sp + nrow(pairs)

      # Distance filter flags for each edge (TRUE = keep, FALSE = drop)
      keep_flag <- rep(TRUE, nrow(pairs))

      # Group edges by origin node i to reuse geometry lookups
      idx_by_i  <- split(seq_len(nrow(pairs)), pairs$i)

      for (i_chr in names(idx_by_i)) {
        idxs  <- idx_by_i[[i_chr]]
        u_idx <- as.integer(i_chr)

        pid_i <- id2patch[u_idx]
        pid_j <- id2patch[pairs$j[idxs]]

        # Look up polygon rows for the origin and targets
        poly_i <- pid_to_poly_sp[as.character(pid_i)]
        rows_j <- unname(pid_to_poly_sp[as.character(pid_j)])

        # Compute distances from patch i to all neighbour patches j
        # using great-circle distance on the sf geometries.
        dists     <- sf::st_distance(geom_sp[poly_i], geom_sp[rows_j])
        dists_num <- as.numeric(dists)

        # Treat NAs as 0 → conservatively keep those edges
        if (anyNA(dists_num)) {
          dists_num[is.na(dists_num)] <- 0
        }

        # Mark edges that exceed the dispersal distance for removal
        keep_flag[idxs] <- dists_num <= disp_m
      }

      # If all edges survive, PU connectivity is unaffected by distance
      if (all(keep_flag)) next

      # Drop edges that fail the distance test from both directions
      drop_idx <- which(!keep_flag)
      edges_dropped_sp <- edges_dropped_sp + length(drop_idx)

      for (k_edge in drop_idx) {
        u <- pairs$i[k_edge]
        v <- pairs$j[k_edge]

        if (length(adj[[u]])) {
          adj[[u]] <- adj[[u]][adj[[u]] != v]
        }
        if (length(adj[[v]])) {
          adj[[v]] <- adj[[v]][adj[[v]] != u]
        }
      }

      # Rebuild CSR from updated adjacency lists
      lens_new    <- vapply(adj, length, integer(1L))
      row_ptr_new <- as.integer(c(0L, cumsum(lens_new)))
      col_idx_new <- as.integer(unlist(adj, use.names = FALSE))
      if (!length(col_idx_new)) col_idx_new <- integer(0L)

      # Current patch areas for this PU, via (species, pu_id) index:
      #   • behaviour: ensures components get correct area sums;
      #   • runtime: index avoids scanning the whole patch_dt.
      pu_rows_now <- patch_dt[
        .(sp, pu),
        .(patch_id, patch_area_km2),
        on = .(species, pu_id)
      ]

      patch_area_vec <- pu_rows_now$patch_area_km2[
        match(id2patch, pu_rows_now$patch_id)
      ]
      patch_area_vec[is.na(patch_area_vec)] <- 0

      # Minimal CSR object passed into .update_pu_components().
      # That helper:
      #   • finds connected components after edge removals,
      #   • drops components whose PU area < species threshold,
      #   • assigns new PU IDs to surviving components,
      #   • returns new CSR objects and IDs to drop.
      conn_mod <- list(
        pu_id    = pu,
        id2patch = id2patch,
        row_ptr  = row_ptr_new,
        col_idx  = col_idx_new
      )

      res <- .update_pu_components(
        conn        = conn_mod,
        alive_nodes = rep(TRUE, length(id2patch)),
        patch_area  = patch_area_vec,
        thr         = min_pu_by_species[[sp]],
        next_pu_id  = next_pu_id_sp
      )

      next_pu_id_sp  <- res$next_pu_id
      drop_patch_ids <- res$drop_patches

      ## ----------------------------------------------------
      ## Step 3f: Drop patches in sub-threshold components
      ##
      ## Behaviour:
      ##   • Removes PU fragments too small to be viable for this species.
      ## Runtime + memory:
      ##   • Shrinks patch_dt, rasters, and graphs as PUs vanish.
      ## ----------------------------------------------------
      if (length(drop_patch_ids)) {
        dropped_patches_sp <- dropped_patches_sp + length(drop_patch_ids)

        # Remove dropped patches from patch_dt for this PU/species
        patch_dt <- patch_dt[
          !(species == sp & pu_id == pu & patch_id %in% drop_patch_ids)
        ]

        # Clear dropped patch IDs from raster values and decrement
        # per-cell species counts where necessary.
        lv       <- get_layer_vals(sp)
        cell_idx <- which(!is.na(lv) & (lv %in% drop_patch_ids))

        if (length(cell_idx)) {
          hit <- cell_idx[count_work[cell_idx] > 0L]
          if (length(hit)) {
            count_work[hit] <- count_work[hit] - 1L
          }
          lv[cell_idx] <- NA_integer_
          assign(paste0("vals__", sp), lv, envir = vals_cache)
        }
      }

      ## ----------------------------------------------------
      ## Step 3g: Update CSR entries for surviving components
      ##
      ## Behaviour:
      ##   • state_env_work reflects new PU structure and IDs.
      ##   • patch_dt is updated so each patch points to its
      ##     new PU ID.
      ## ----------------------------------------------------
      csr_list <- res$csr_list
      state_env_work[[key]] <- NULL  # remove original PU graph

      if (!length(csr_list)) {
        # Entire PU disappeared (all components sub-threshold).
        pus_removed_sp <- pus_removed_sp + 1L
      } else {
        for (j in seq_along(csr_list)) {
          cobj    <- csr_list[[j]]
          new_pu  <- cobj$pu_id
          new_key <- paste0(sp, "|", new_pu)

          # Patch areas for this component’s patches, using (species, pu_id) index
          areas_map <- patch_dt[
            .(sp, new_pu),
            .(patch_id, patch_area_km2),
            on = .(species, pu_id)
          ]
          patch_area_vec2 <- areas_map$patch_area_km2[
            match(cobj$id2patch, areas_map$patch_id)
          ]

          # Reconstruct CSR graph object for this component
          state_env_work[[new_key]] <- list(
            species    = sp,
            pu_id      = new_pu,
            id2patch   = cobj$id2patch,
            patch2id   = as.integer(seq_along(cobj$id2patch)),
            row_ptr    = cobj$row_ptr,
            col_idx    = cobj$col_idx,
            alive      = rep(TRUE, length(cobj$id2patch)),
            patch_area = patch_area_vec2,
            comp_id    = rep(1L, length(cobj$id2patch)),
            comp_area  = sum(patch_area_vec2, na.rm = TRUE)
          )

          # Ensure patch_dt records the new PU ID for all patches in this component
          patch_dt[species == sp & patch_id %in% cobj$id2patch,
                   pu_id := new_pu]
        }
      }
    } # end PU loop

    ## ------------------------------------------------------
    ## 3h. Accumulate per-species statistics for final log
    ##
    ## All quantities are either already computed or extremely cheap:
    ##   • n_pu_sp, n_changed_sp, length(cand_patch_ids_sp)
    ##   • edges_checked_sp, edges_dropped_sp
    ##   • dropped_patches_sp, pus_removed_sp
    ##   • n_alive_before_sp, n_alive_after_sp
    ##
    ## We aggregate them into global counters so that only a single,
    ## pipeline-wide log is emitted after all species are processed.
    ## This keeps logging overhead minimal while still giving a
    ## detailed view of each stage.
    ## ------------------------------------------------------
    total_species_touched    <- total_species_touched + 1L
    total_pus_touched        <- total_pus_touched + n_pu_sp
    total_changed_patches    <- total_changed_patches + n_changed_sp
    total_candidate_patches  <- total_candidate_patches + length(cand_patch_ids_sp)
    total_edges_checked      <- total_edges_checked + edges_checked_sp
    total_edges_dropped      <- total_edges_dropped + edges_dropped_sp
    total_patches_dropped    <- total_patches_dropped + dropped_patches_sp
    total_pus_removed        <- total_pus_removed + pus_removed_sp
    
    # NEW: drop cached values for this species to keep only one species' values in RAM
    rm(list = paste0("vals__", sp), envir = vals_cache)
    gc()
  }   # end species loop

  ## ----------------------------------------------------------
  ## 4. Remove CSR entries for PUs that no longer exist
  ##
  ## Behaviour:
  ##   • Keeps state_env_work in sync with patch_dt.
  ## Runtime/memory:
  ##   • Avoids carrying dead PUs in later stages, keeping graphs small.
  ## ----------------------------------------------------------
  pu_dt_refined <- patch_dt[
    ,
    .(pu_area_km2 = sum(patch_area_km2, na.rm = TRUE)),
    by = .(species, pu_id)
  ]

  keep_keys <- paste0(pu_dt_refined$species, "|", as.integer(pu_dt_refined$pu_id))
  drop_keys <- setdiff(names(state_env_work), keep_keys)
  for (k in drop_keys) state_env_work[[k]] <- NULL

  ## ----------------------------------------------------------
  ## 5. Cells that lost their last species in this distance step
  ##
  ## Behaviour:
  ##   • removed_indices flags cells that transitioned from >=1 species
  ##     to 0 species purely because of the distance stage.
  ##   • orchestrator uses this to build diagnostic masks / logs.
  ## ----------------------------------------------------------
  removed_idx <- which(count_alive > 0L & count_work == 0L)

  ## ----------------------------------------------------------
  ## 6. Single distance-stage summary log
  ##
  ## All values are derived from cheap per-species scalars:
  ##   • Stage 1 (candidate selection): species_touched, PUs_touched,
  ##     changed_patches, cand_patches.
  ##   • Stage 3 (graph updates): edges_checked, edges_dropped,
  ##     dropped_patches, removed_PUs.
  ##   • Overall effect: alive_cells_before/after and cells_lost.
  ##
  ## No additional raster or sf work is performed here; only integer
  ## arithmetic on counters accumulated above.
  ## ----------------------------------------------------------

  .log_console(
    "connectivity",
    "[%s] Distance stage complete: species_touched=%d, PUs_touched=%d, changed_patches=%d, cand_patches=%d, edges_checked=%d, edges_dropped=%d, dropped_patches=%d, removed_PUs=%d.",
    format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
    total_species_touched,
    total_pus_touched,
    total_changed_patches,
    total_candidate_patches,
    total_edges_checked,
    total_edges_dropped,
    total_patches_dropped,
    total_pus_removed
  )

  ## ----------------------------------------------------------
  ## 7. Final output: updated tables + per-cell counts
  ## ----------------------------------------------------------
  rm(recheck_dt, recheck_pus, vals_cache)
  gc()
  
  list(
    patch_dt        = patch_dt,
    state_env       = state_env_work,
    count_alive     = count_work,
    removed_indices = removed_idx
  )
}
```

# run_global_orchestrator_simplified

```{r}
# ------------------------------------------------------------
# 6. Global Orchestrator (ultra-minimal: prune → frag → distance)
#
# Role in the pipeline
# --------------------
# This function runs the three main spatial stages in order:
#   1) Pruning      – remove edge cells from patches.
#   2) Fragmentation – update patch IDs / PUs when patches are broken apart.
#   3) Distance     – enforce species-specific dispersal limits between patches.
#
# Design goals
# ------------
# • Achieve desired behaviour:
#     - Apply all three stages in the correct order.
#     - Pass updated state objects between stages.
#     - Write diagnostic rasters for removed cells at each stage.
#     - Save enough state to resume from the end of the last completed stage.
#
# • Reduce runtime:
#     - Only call each stage once per global "stage_iter".
#     - Avoid any redundant recomputation or checks here; delegate work to the
#       specialised orchestrators (pruning, fragmentation, distance).
#
# • Reduce memory usage:
#     - Reuse the same objects (patch_dt, state_env, count_alive, patch_stack)
#       in-place across iterations instead of creating new copies.
#     - Save only the minimal required resume state to disk (no static params).
# ------------------------------------------------------------
run_global_orchestrator_simplified <- function(
  n_remove,                    # edge cells to remove per pruning iteration
  k,                           # pruning iterations per stage
  patch_dt,                    # data.table: species, patch_id, pu_id, patch_area_km2
  state_env,                   # list: connectivity per PU (CSR), keys "species|pu_id"
  count_alive,                 # integer vector: per-cell count of species present
  patch_stack,                 # SpatRaster: one layer per species with patch IDs per cell
  cs_vals,                     # numeric vector: per-cell area (km^2)
  rook_pairs_all,              # integer matrix: rook-adjacent cell index pairs
  params,                      # data.table: species parameters (min_patch_size, dispersal, etc.)
  output_dir       = "Spatial/Outputs",
  max_stages       = 1000L,
  start_stage_iter = 1L
) {

  # Global loop over "stages":
  #   • Each iteration performs pruning → fragmentation → distance on the
  #     current state.
  #   • We stop when pruning reports that its frontier is exhausted
  #     (no more edge cells to remove).
  for (stage_iter in seq(from = start_stage_iter, to = max_stages)) {

    # ========================================================
    # 1) PRUNING STAGE
    #
    # Behaviour:
    #   • Removes up to n_remove edge cells per patch per iteration,
    #     repeated k times.
    #   • Updates:
    #       - patch_dt    (patch areas / IDs)
    #       - state_env   (CSR connectivity structures)
    #       - count_alive (per-cell species-counts)
    #   • Returns:
    #       - changed_patch_areas: patches whose shapes/areas changed
    #       - frontier_exhausted: TRUE when no more cells can be pruned
    #
    # Runtime/memory:
    #   • All heavy spatial work is encapsulated in run_pruning_orchestrator.
    #   • We only reassign returned objects (no extra copies).
    # ========================================================
    prune_out <- run_pruning_orchestrator(
      k              = k,
      n_remove       = n_remove,
      patch_dt       = patch_dt,
      state_env      = state_env,
      count_alive    = count_alive,
      patch_stack    = patch_stack,
      cs_vals        = cs_vals,
      rook_pairs_all = rook_pairs_all,
      params         = params,
      output_dir     = output_dir,
      stage_iter     = stage_iter
    )

    # Overwrite in-place: these are the canonical state objects for the next stages.
    patch_dt           <- prune_out$patch_dt
    state_env          <- prune_out$state_env
    count_alive        <- prune_out$count_alive
    changed_patches    <- prune_out$changed_patch_areas
    frontier_exhausted <- prune_out$frontier_exhausted

    # ========================================================
    # 2) FRAGMENTATION STAGE
    #
    # Behaviour:
    #   • Applies patch / PU updates when pruning breaks patches apart.
    #   • Ensures patch_dt, patch_stack, state_env remain consistent
    #     after internal fragmentation.
    #   • Returns:
    #       - removed_indices: cell indices dropped by fragmentation rules
    #       - patch_ids_to_recheck: patches whose geometry changed and must
    #         be re-checked in the distance stage.
    #
    # Runtime:
    #   • Only fragments where pruning actually changed patch areas.
    # Memory:
    #   • Reuses patch_stack and patch_dt, assigning updated versions.
    # ========================================================
    frag_out <- apply_patch_fragmentation_updates(
      patch_stack         = patch_stack,
      patch_dt            = patch_dt,
      state_env           = state_env,
      changed_patch_areas = changed_patches,
      cs_vals             = cs_vals,
      params              = params,
      count_alive         = count_alive
    )

    removed_frag <- frag_out$removed_indices

    patch_stack <- frag_out$patch_stack
    patch_dt    <- frag_out$patch_dt
    state_env   <- frag_out$state_env
    count_alive <- frag_out$count_alive
    recheck_ids <- frag_out$patch_ids_to_recheck

    # --------------------------------------------------------
    # Diagnostic raster: cells removed by fragmentation
    #
    # Behaviour:
    #   • Records which cells were lost at this stage in a binary mask
    #     (1 = removed, NA = otherwise).
    # Runtime/memory:
    #   • Only created if there were actually removed cells.
    #   • Uses existing patch_stack[[1]] as a template, so we avoid
    #     creating new rasters from scratch.
    # --------------------------------------------------------
    if (length(removed_frag) > 0L) {
      mask_frag <- terra::setValues(patch_stack[[1]], NA_integer_)
      mask_frag[removed_frag] <- 1L
      fn_frag <- file.path(
        output_dir,
        sprintf("removed_mask_fragmentation_stage_%04d.tif", stage_iter)
      )
      terra::writeRaster(mask_frag, filename = fn_frag, overwrite = TRUE)
    }

    # ========================================================
    # 3) DISTANCE STAGE
    #
    # Behaviour:
    #   • Enforces species-specific maximum dispersal distances between patches.
    #   • May:
    #       - drop edges in PU connectivity graphs (state_env),
    #       - split PUs into components,
    #       - drop sub-threshold components,
    #       - update patch_dt and count_alive accordingly.
    #   • Only rechecks patches flagged by fragmentation (recheck_ids),
    #     which reduces unnecessary distance calculations.
    #
    # Runtime:
    #   • Distance work is limited to changed patches + neighbours.
    # Memory:
    #   • Reuses the same patch_stack and patch_dt; only minimal outputs
    #     (removed_indices) are extracted for diagnostics.
    # ========================================================
    dist_out <- update_connectivity_after_distance(
      patch_stack          = patch_stack,
      patch_dt             = patch_dt,
      state_env            = state_env,
      patch_ids_to_recheck = recheck_ids,
      params               = params,
      count_alive          = count_alive
    )

    removed_dist <- dist_out$removed_indices

    patch_dt    <- dist_out$patch_dt
    state_env   <- dist_out$state_env
    count_alive <- dist_out$count_alive

    # --------------------------------------------------------
    # Diagnostic raster: cells removed by distance step
    #
    # Behaviour:
    #   • Records which cells were lost at the distance stage.
    # Runtime/memory:
    #   • Only written if any cells were removed.
    #   • Reuses existing raster geometry (patch_stack[[1]]).
    # --------------------------------------------------------
    if (length(removed_dist) > 0L) {
      mask_dist <- terra::setValues(patch_stack[[1]], NA_integer_)
      mask_dist[removed_dist] <- 1L
      fn_dist <- file.path(
        output_dir,
        sprintf("removed_mask_distance_stage_%04d.tif", stage_iter)
      )
      terra::writeRaster(mask_dist, filename = fn_dist, overwrite = TRUE)
    }

    # ========================================================
    # 4) SAVE PER-STAGE CHECKPOINT (RESUME INFO)
    #
    # Behaviour:
    #   • Allows the entire pipeline to be resumed from the end of the
    #     last completed stage without rerunning earlier stages.
    #   • We save:
    #       - patch_dt: current patch-to-PU mapping and areas.
    #       - state_env: current CSR graphs for PUs.
    #       - count_alive: current per-cell species counts.
    #       - patch_stack_file: where to reload the current patch_stack.
    #
    # Runtime/memory:
    #   • Writes patch_stack once per stage to disk (needed anyway for
    #     downstream spatial analyses).
    #   • The RDS only holds the minimal evolving state needed to resume.
    # ========================================================
    patch_stack_file <- file.path(
      output_dir,
      sprintf("patch_stack_stage_%04d.tif", stage_iter)
    )
    terra::writeRaster(patch_stack, patch_stack_file, overwrite = TRUE)

    resume_state <- list(
      patch_dt         = patch_dt,
      state_env        = state_env,
      count_alive      = count_alive,
      patch_stack_file = patch_stack_file
    )

    state_file <- file.path(
      output_dir,
      sprintf("global_state_stage_%04d.rds", stage_iter)
    )
    saveRDS(resume_state, state_file)

    # ========================================================
    # 5) STOP CONDITION
    #
    # Behaviour:
    #   • The global loop ends when pruning reports that the frontier is
    #     exhausted — i.e., there are no edge cells left to prune.
    #
    # Runtime:
    #   • Avoids unnecessary extra global stages once the process can
    #     no longer change the configuration.
    # ========================================================
    if (frontier_exhausted) break
  }

  # The orchestrator's purpose is side effects (writing rasters + RDS),
  # not returning objects to the caller. invisible(NULL) prevents large
  # objects from being printed to the console and keeps memory overhead low.
  invisible(NULL)
}
```

# From-scratch global orchestrator call (using initial inputs)

```{r eval=FALSE, include=FALSE}
# ------------------------------------------------------------
# Load initial dynamic state for the FROM-SCRATCH run
# ------------------------------------------------------------
orchestrator_init <- readRDS(
  file.path("Spatial", "global_orchestrator_init.rds")
)

patch_dt       <- orchestrator_init$patch_dt
state_env      <- orchestrator_init$state_env
count_alive    <- orchestrator_init$count_alive
patch_stack_file <- orchestrator_init$patch_stack_file

# Load initial patch_stack from its own file
patch_stack <- terra::rast(patch_stack_file)
# If needed:
# names(patch_stack) <- params$species

rm(orchestrator_init, patch_stack_file)
gc(verbose = FALSE)

# ------------------------------------------------------------
# Run global orchestrator from the original initial state
# ------------------------------------------------------------
run_global_orchestrator_simplified(
  n_remove       = 1000,
  k              = 50,
  patch_dt       = patch_dt,
  state_env      = state_env,
  count_alive    = count_alive,
  patch_stack    = patch_stack,
  cs_vals        = cs_vals,         # from shared setup chunk
  rook_pairs_all = rook_pairs_all,  # from shared setup chunk
  params         = params,          # from shared setup chunk
  output_dir     = "Spatial/Outputs",
  max_stages     = 50L
)
```

# Resume global orchestrator call (starting after stage n)

```{r}
# ------------------------------------------------------------
# Load dynamic state from the end of stage n
#   (written by run_global_orchestrator_simplified at stage_iter = n)
# ------------------------------------------------------------
stage_n <- 24L  # or whatever integer stage you want

resume_state <- readRDS(
  file.path(
    "Spatial",
    "Outputs",
    sprintf("global_state_stage_%04d.rds", stage_n)
  )
)

patch_dt    <- resume_state$patch_dt
state_env   <- resume_state$state_env
count_alive <- resume_state$count_alive

# Load the corresponding patch_stack from its checkpoint file
patch_stack <- terra::rast(resume_state$patch_stack_file)

rm(resume_state)
gc(verbose = FALSE)

# ------------------------------------------------------------
# Resume global orchestrator AFTER completing stage n
# ------------------------------------------------------------
run_global_orchestrator_simplified(
  n_remove        = 1000,
  k               = 50,
  patch_dt        = patch_dt,
  state_env       = state_env,
  count_alive     = count_alive,
  patch_stack     = patch_stack,
  cs_vals         = cs_vals,         # from shared setup chunk
  rook_pairs_all  = rook_pairs_all,  # from shared setup chunk
  params          = params,          # from shared setup chunk
  output_dir      = "Spatial/Outputs",
  max_stages      = 50L,
  start_stage_iter = stage_n + 1     # resume AFTER completing stage n
)
```