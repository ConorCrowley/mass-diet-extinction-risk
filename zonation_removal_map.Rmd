---
title: "zonation_removal_map"
output: html_document
---

```{r}
# Load libraries
library(terra)
library(sf)
library(igraph)
library(dplyr)
library(fasterRaster)

# Use spherical geometry off for sf (consistent with original scripts)
sf::sf_use_s2(TRUE)

# Initialize fasterRaster with GRASS (adjust path if needed)
faster(grassDir = "C:/Program Files/GRASS GIS 8.4")

# Simple log helper to report progress by species
log_step <- function(spp, msg) {
  message(sprintf("[%s] [%s] %s",
                  format(Sys.time(), "%Y-%m-%d %H:%M:%S"),
                  spp, msg))
}

# 1. Load habitat masks and define template grid
masks <- terra::rast("Spatial/masks.tif")
template <- masks[[1]]

# 2. Load species data (mammals and birds), filter and format
mammal_df <- read.csv("Data/Clean/mammal_data.csv", stringsAsFactors = FALSE)
bird_df   <- read.csv("Data/Clean/bird_data.csv",   stringsAsFactors = FALSE)

# (Optional) Filter to target focal species (as in original scripts)
target_species_mammal <- c(
  "gymnuromys roberti", "nesomys rufus", "eliurus minor", "eliurus majori",
  "eliurus myoxinus", "eliurus tanala", "eliurus webbi", "cryptoprocta ferox",
  "fossa fossana", "galidia elegans", "echinops telfairi",
  "hemicentetes semispinosus", "microgale brevicaudata", "microgale cowani",
  "nesogale dobsoni", "microgale gymnorhyncha", "microgale longicaudata",
  "microgale parvula", "microgale principula", "microgale soricoides",
  "microgale taiva", "nesogale talazaci", "oryzorictes hova",
  "setifer setosus", "tenrec ecaudatus", "eulemur fulvus", "eulemur rufus",
  "hapalemur griseus", "indri indri", "lepilemur edwardsi",
  "lepilemur leucopus", "lepilemur ruficaudatus",
  "varecia variegata", "cheirogaleus medius", "cheirogaleus major",
  "microcebus rufus", "eulemur albifrons", "eulemur coronatus",
  "microcebus murinus", "eulemur rubriventer", "lepilemur mustelinus"
)
target_species_bird <- c(
  "accipiter madagascariensis", "coua coquereli", "coua serriana",
  "coua cursor", "apus balstoni", "asio madagascariensis",
  "philepitta castanea", "neodrepanis coruscans", "foudia madagascariensis",
  "hartlaubius auratus", "foudia omissa", "ploceus nelicourvi",
  "accipiter henstii", "newtonia amphichroa", "mentocrex kioloides",
  "calicalicus madagascariensis", "coua cristata", "brachypteracias leptosomus",
  "lophotibis cristata", "atelornis crossleyi", "turnix nigricollis",
  "buteo brachypterus", "pterocles personatus",
  "corythornis madagascariensis", "lepidopygia nana",
  "eremopterix hova", "acrocephalus newtoni", "motacilla flaviventris",
  "monticola sharpei", "xanthomixis cinereiceps", "oxylabes madagascariensis",
  "neomixis viridis", "hypositta corallirostris", "newtonia brunneicauda",
  "mystacornis crossleyi", "cyanolanius madagascarinus",
  "xanthomixis zosterops", "bernieria madagascariensis", "coua gigas",
  "pseudobias wardi", "neomixis striatigula", "gactornis enarratus",
  "coracopsis nigra", "athene superciliaris",
  "alectroenas madagascariensis", "polyboroides radiatus",
  "tylas eduardi", "aviceda madagascariensis",
  "vanga curvirostris", "leptopterus chabert", "artamella viridis",
  "sarothrura insularis", "otus rutilus", "cinnyris notatus",
  "treron australis"
)

# Filter and format mammal species
mammal_df <- mammal_df %>%
  filter(scientificName %in% target_species_mammal) %>%
  mutate(scientificName = tolower(gsub(" ", "_", scientificName)))
mammal_df$group <- "Mammal"

# Filter and format bird species
bird_df <- bird_df %>%
  filter(scientificName %in% target_species_bird) %>%
  mutate(scientificName = tolower(gsub(" ", "_", scientificName)))
bird_df$group <- "Bird"

# Combine species data frames
species_df <- bind_rows(mammal_df, bird_df)

# 3. Load presence rasters aligned to the template grid
pres_rasters <- list()

# Mammal presence rasters
mammal_files <- list.files("Spatial/mammal_ppm_bin", pattern = "\\.tif$", full.names = TRUE)
mammal_names <- tools::file_path_sans_ext(basename(mammal_files))
mammal_names <- tolower(sub("_bin$", "", mammal_names))
mammal_resolved <- tolower(species_df$scientificName[species_df$group == "Mammal"])
keep_idx <- mammal_names %in% mammal_resolved
mammal_files <- mammal_files[keep_idx]
mammal_names <- mammal_names[keep_idx]
for (k in seq_along(mammal_files)) {
  r0 <- terra::rast(mammal_files[k])
  r1 <- terra::project(r0, y = template, method = "near")
  pres_rasters[[mammal_names[k]]] <- r1
}

# Bird presence rasters
bird_files <- list.files("Spatial/bird_ppm_bin", pattern = "\\.tif$", full.names = TRUE)
bird_names <- tools::file_path_sans_ext(basename(bird_files))
bird_names <- tolower(sub("_bin$", "", bird_names))
bird_resolved <- tolower(species_df$scientificName[species_df$group == "Bird"])
keep_idx <- bird_names %in% bird_resolved
bird_files <- bird_files[keep_idx]
bird_names <- bird_names[keep_idx]
for (k in seq_along(bird_files)) {
  r0 <- terra::rast(bird_files[k])
  r1 <- terra::project(r0, y = template, method = "near")
  pres_rasters[[bird_names[k]]] <- r1
}

# 4. Load and align the zonation removal-order raster (rankmap)
rankmap <- terra::rast("Spatial/rankmap.tif")
rankmap <- terra::project(rankmap, y = template, method = "near")
# Note: rankmap values ∈ [0,1], with higher values indicating cells removed later.

# 5. Build an "alive mask" at a given removal proportion
build_alive_mask <- function(rankmap, removal_prop) {
  # Keep cells with rank >= removal_prop (alive until this stage)
  terra::ifel(rankmap >= removal_prop, 1L, NA_integer_)
}

# 6. Build base suitability raster for a species (habitat ∩ presence)
build_suitability <- function(sci, species_row, masks, pres_rasters, habitat_map) {
  hraw <- species_row$habitats_mixed
  labels <- if (is.na(hraw)) character(0) else trimws(strsplit(hraw, ",")[[1]])
  mask_names <- unname(habitat_map[labels])
  mask_names <- mask_names[!is.na(mask_names)]
  mask_names <- unique(mask_names[mask_names %in% names(masks)])
  if (length(mask_names) == 0L) {
    return(NULL)  # No valid habitat
  }
  if (length(mask_names) == 1L) {
    hab_union <- masks[[mask_names]]
  } else {
    sum_rast <- terra::app(masks[[mask_names]], fun = sum, na.rm = TRUE)
    hab_union <- terra::ifel(sum_rast > 0, 1L, NA_integer_)
  }
  pres <- pres_rasters[[sci]]
  if (is.null(pres)) {
    return(NULL)  # No presence raster
  }
  # 1 where habitat present AND species present, else NA
  suit0 <- hab_union * pres
  return(suit0)
}

# Habitat mapping (IUCN label → mask layer name)
habitat_map <- c(
  "Forest" = "forest",
  "Savanna" = "savanna",
  "Shrubland" = "shrubland",
  "Grassland" = "grassland",
  "Wetlands (inland)" = "wetlands",
  "Rocky Areas (e.g., inland cliffs, mountain peaks)" = "rocky_areas",
  "Desert" = "desert",
  "Arable & Pastureland" = "artificial_arable_pasture",
  "Plantations & Heavily Degraded Former Forest" = "artificial_degraded_forest_plantation",
  "Urban & Rural Gardens" = "artificial_urban_rural_gardens",
  "Artificial - Aquatic" = "artificial_aquatic"
)

# 7. Function to rebuild patches/PUs and return patch lookup at one removal_prop
build_patch_lookup_for_removal_prop <- function(
  removal_prop, rankmap, species_df, masks, pres_rasters, habitat_map
) {
  alive_mask <- build_alive_mask(rankmap, removal_prop)
  patch_lookup_list <- list()
  for (i in seq_len(nrow(species_df))) {
    sci <- species_df$scientificName[i]
    log_step(sci, sprintf("removal_prop=%.2f START", removal_prop))
    print(removal_prop)
    # Build suitability (habitat ∩ presence)
    suit0 <- build_suitability(sci, species_df[i, ], masks, pres_rasters, habitat_map)
    if (is.null(suit0)) {
      log_step(sci, "SKIP (no habitat/presence)")
      next
    }
    # Restrict to alive habitat
    suit_stage <- suit0 * alive_mask
    # If no cells remain alive, skip
    if (terra::global(suit_stage, fun = "sum", na.rm = TRUE) == 0) {
      log_step(sci, "SKIP (no alive habitat at this stage)")
      next
    }
    # Trim NA border for efficiency
    suit_trim <- terra::trim(suit_stage)
    # Identify patches (clumps) in 4-neighbor connectivity
    cl_fast <- fasterRaster::clump(fasterRaster::fast(suit_trim), diagonal = FALSE)
    cl_spat <- terra::rast(cl_fast)
    # Compute patch areas (sum of cell areas in km²)
    cell_area_km <- terra::cellSize(suit_trim, unit = "km")
    area_tab <- as.data.frame(terra::zonal(cell_area_km, cl_spat, "sum", na.rm = TRUE))
    names(area_tab) <- c("old_id", "area_km2")
    # Filter patches by min_patch_size
    min_patch <- species_df$min_patch_size[i]
    keep_old <- area_tab$old_id[area_tab$area_km2 >= min_patch]
    if (!length(keep_old)) {
      log_step(sci, "SKIP (no patches ≥ min_patch_size)")
      next
    }
    # Reindex kept patches and extend to full extent
    kept_ids_trim <- terra::classify(
      cl_spat,
      rcl = cbind(as.integer(keep_old), seq_along(keep_old)),
      others = NA_integer_
    )
    kept_ids_full <- terra::extend(kept_ids_trim, suit_stage)
    patches_tab <- data.frame(
      patch_id = seq_along(keep_old),
      patch_area_km2 = area_tab$area_km2[match(keep_old, area_tab$old_id)]
    )
    # Compute PUs (patch groups) via dispersal distance
    log_step(sci, "Form PUs via dispersal")
    patches_sf <- sf::st_as_sf(
      terra::as.polygons(kept_ids_full, values = TRUE, dissolve = TRUE)
    )
    patch_col <- setdiff(names(patches_sf), attr(patches_sf, "sf_column"))[1]
    patches_sf$patch_id <- as.integer(patches_sf[[patch_col]])
    patches_sf <- patches_sf[!is.na(patches_sf$patch_id), ]
    nb <- sf::st_is_within_distance(
      patches_sf, patches_sf,
      dist = species_df$dispersal_dist[i] * 1000
    )
    g <- igraph::graph_from_adj_list(nb, mode = "out") |>
      igraph::as_undirected("collapse") |>
      igraph::simplify(remove.multiple = TRUE, remove.loops = TRUE)
    comp <- igraph::components(g)$membership
    patches_sf$pu_id_unfiltered <- as.integer(match(comp, sort(unique(comp))))
    patch_to_pop <- data.frame(
      patch_id = patches_sf$patch_id,
      pu_id_unfiltered = patches_sf$pu_id_unfiltered
    )
    # Filter PUs by total area ≥ min_patch_size500
    patch_area_df <- merge(patches_tab, patch_to_pop, by = "patch_id")
    pop_area_df <- aggregate(
      patch_area_km2 ~ pu_id_unfiltered,
      patch_area_df, sum, na.rm = TRUE
    )
    names(pop_area_df) <- c("pu_id_unfiltered", "pu_area_km2")
    keep_pu <- sort(
      pop_area_df$pu_id_unfiltered[
        pop_area_df$pu_area_km2 >= species_df$min_patch_size500[i]
      ]
    )
    if (!length(keep_pu)) {
      log_step(sci, "SKIP (no PUs ≥ min_patch_size500)")
      next
    }
    patch_to_pop$pu_id_final <- match(patch_to_pop$pu_id_unfiltered, keep_pu)
    patch_to_pop_kept <- patch_to_pop[!is.na(patch_to_pop$pu_id_final), ]
    # Final patch IDs and lookup table for this species and removal_prop
    keep_patch_ids <- sort(patch_to_pop_kept$patch_id)
    final_ids <- seq_along(keep_patch_ids)
    names(final_ids) <- as.character(keep_patch_ids)
    patch_lookup_stage <- data.frame(
      species = sci,
      patch_id = final_ids[as.character(patch_to_pop_kept$patch_id)],
      pu_id = patch_to_pop_kept$pu_id_final,
      patch_area_km2 = patches_tab$patch_area_km2[
        match(patch_to_pop_kept$patch_id, patches_tab$patch_id)
      ],
      removal_prop = removal_prop,
      stringsAsFactors = FALSE
    )
    patch_lookup_list[[length(patch_lookup_list) + 1]] <- patch_lookup_stage
    log_step(sci, "DONE")
  }
  # Combine per-species results
  if (length(patch_lookup_list) > 0) {
    patch_lookup_df <- do.call(rbind, patch_lookup_list)
  } else {
    patch_lookup_df <- data.frame(
      species = character(0), patch_id = integer(0),
      pu_id = integer(0), patch_area_km2 = numeric(0),
      removal_prop = numeric(0), stringsAsFactors = FALSE
    )
  }
  return(patch_lookup_df)
}

# 8. Prepare output directory
out_dir <- file.path("Spatial", "zonation_Outputs")
if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

save_patch_lookup <- function(patch_lookup, removal_prop, out_dir) {
  fname <- sprintf("patch_lookup_zonation_rank_%.2f.rds", removal_prop)
  out_path <- file.path(out_dir, fname)
  saveRDS(patch_lookup, out_path)
}

# Driver: process multiple removal proportions
removal_props <- seq(from = 0.025, to = 0.975, by = 0.05)
for (rp in removal_props) {
  message("===== Processing removal_prop = ", rp, " =====")
  patch_lookup_rp <- build_patch_lookup_for_removal_prop(
    removal_prop = rp,
    rankmap      = rankmap,
    species_df   = species_df,
    masks        = masks,
    pres_rasters = pres_rasters,
    habitat_map  = habitat_map
  )
  save_patch_lookup(patch_lookup_rp, rp, out_dir)
  message("===== Done removal_prop = ", rp, " =====")
}
```
